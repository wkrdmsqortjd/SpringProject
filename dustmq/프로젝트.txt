https://velog.io/@alicesykim95/Git-Project-Upload-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%97%85%EB%A1%9C%EB%93%9C
간단한 git 사용법

	작성 순서 

	1. DB 테이블 생성 및 VO 생성
	  1) Oracle
	  2) VO 생성
	
	2. MemberMapper.xml 추가
	  1) insert 쿼리문 테스트 및 관리자 아이디 만들기
	  2) mapper.xml 작성
	  
	3. MemberMapper.java 인터페이스 추가
	
	4. Mapper에 추가한 쿼리문 테스트 (MemberMapperTests.java)
	
	5. MemberService.java 추가
	
	6. MemberController.java 회원가입 메서드 추가
	
	7. join.jsp
	
	8. 테스트
	
	관리자 여부는 int형으로 0은 일반, 1은 관리자로 하여 로그인한 사람이 회원인지 관리자인지 구분하기 위해 사용
	
	
	회원가입 흐름
	<실행 흐름의 순서>
	
	join.jsp에서 필요한 데이터를 입력 후 '가입하기' 버튼을 클릭
	
						↓
	
	MemberCotroller에서 joinPost(MemberVO member) 메서드 실행
	MemberService.memberJoin(member) 메서드 호출(회원가입)		→ 	MemberService에서 MemberMapper.memberJoin(member) 메서드 호출
	"redirect:/main"으로 메인페이지로 모든 로직이 끝나면 이동											↓
	
						↓										MemberMapper에서 memberJoin(MemberVO member) 메서드 호출
				
					main.jsp																↓
	 														
	 															MemberMapper.xml 에서 id="memberJoin" 실행
	 																						↓
	 																
	 																			Orcle DB에서 쿼리 명령 실행
	 																
	
	
	3
	<아이디 중복확인 흐름>
	
	join.jsp 에서 가입할 아이디 입력
	반환 결과 따른 span태그 출력
			
			   ↓
				
	MemberController										→	MemberService에서 idCheck() 실행				
	에서 memberIdChkPost() 실행									int데이터 수신 받은 뒤 controller로 반환
	int결과 수신 받은뒤 그 결과 따른 String 데이터를 join.jsp로 반환		
																			  ↓			
						
																MemberMapper 에서 idCheck() 실행
																int데이터 수신 받은 뒤 service로 반환
																
																			  ↓	
																			  
															  	MemberMapper.xml 에서 idCheck 실행하여 DB로부터 쿼리문 요청
															  	DB로부터 결과값 받은 int형 데이터 Mapper.java로 반환
															  	
															  	
  	6월 17일 회원가입 기능 완성 ( 이메일 기능 일부 못함 )
  
  	비밀번호 인코딩 차례
  	<스프링 시큐리티> : 자바 서버 개발을 위해 필요로 한 인증, 권한 부여 및 기타 보안 기능을 제공하는 프레임 워크
  	
  	주요 프레임 워크 : BCryptPasswordEncoder BCrypt 해싱 함수 BCrypthashing function)를 사용해
  				  비밀번호를 인코딩해주는 메서드와 사용자의 의해 제출된 비밀번호와 DB에 저장되어 있는 비밀번호의 일치 여부를
  				  확인해주는 메서드를 제공
  				  
    - 회원가입 메서드를 수정 후 흐름
    
    회원정보가 담긴 member -> member에 저장된 비밀번호를 꺼냄 -> encode() 메서드를 통해 꺼낸 비밀번호 인코딩 ->
    인코딩 된 비밀번호를 member 객체에 다시 저장 -> memberJoin()을 호출하여 회원가입 쿼리 실행
    
    오류 : context:component-scan에 Controller 패키지를 등록했기 때문에 에러, 컨트롤러는 조정만 할 뿐이다.
    
	
	6월 18일 로그아웃 기능 추가
	
	로그아웃 버튼을 클릭 시 사용자의 session을 삭제
	
	GNB(Global Navigation Bar) 영역 구현 
  	
  	웹 디자인 용어로써 어느 페이지를 들어가든지 공통적으로 사용할 수 있는 메뉴를 의미
  	로그인 상태, 비로그인 상태, 관리자 계정 로그인 상태 등등 메뉴가 다르게 해야함
  	각 상황에 따라 다른 메뉴 구현은 JSTL <c:if>를 사용
  	
  	로그인 상태 -> 표시될 메뉴들로는 '로그아웃', '마이룸', '장바구니'로 구성
  	
  	관리자 계정 메뉴 -> '관리자 페이지' 로 이동할 수 있는 메뉴
  	
  	- 로그아웃 버튼 기능을 비동기식 요청 구현
  	
  	< 흐름 > 
  	
  	원래의 로그아웃 메서드의 경우 메서드 작입이 완료된 뒤 지정된 특정 화면으로만 이동되도록 함
  	로그아웃 버튼의 경우 거의 모든 페이지에 삽입되어야 하는데, 이럴경우 페이지가 많아지면 그 페이지수만큼
  	그에 맞는 로그아웃을 계속 작성해야함. 이런 불편을 해결하고자 로그아웃 버튼 클릭시 특정 화면으로 이동없이
  	현 페이지가 새로고침 됨으로써 화면의 구성이 바뀌도록하는 비동기식 작업이 필요 
  	
  	 로그 아웃 버튼 클릭 => javascript 버튼 메서드 작동 => ajax 통해 로그아웃 요청
  	  => 서버 로그아웃 수행 => 화면 이동없이 새로고침 통해 화면 변환
  	  
    - 로그인, 관리자 메서드 인터셉터 적용
    
    현재 코드에서는 일반 계정 혹은 비로그인 상태로도 관리자 페이지 url만 알고 있다면 접속 가능
    따라서 AdminController에서 관리자 페이지 접속 메서드에 세션 체크를 통해 권한이 없는 관리자가 
    접근 시 메서드 실행이 되지 않도록 로직을 작성해야함 
    AdminController 는 작성된 메서드들은 관리자가 사용할 메서드 들이기 때문에,
    작성될 메서드 전체에 사용자 권한을 확인하는 코드를 중복하여 작성해야 한다.
    이런 권한 체크를 세션 체크 로직처럼 웹을 실행하기 위한 핵심 로직은 아니지만 반드시 필요한
    로직들을 한번의 작성으로 일괄적으로 관리해 줄 수 있도록 해주는 수단, <Interceptor>가 있다.
    <Interceptor>는 Controller를 호출하기 전과 후에 요청과 응답을 참조하거나 가공하는 일종의 필터.
    
    Interceptor 적용 대상
    -AdminController 전체
    -MemberController 의 로그인 메서드
    
    - 작가 테이블 구성 & 기타 작업 (로고, footer, 관리자 페이지)
    
    게시판은 주로 CRUD( Create, Read, Update, Delete ) 기능으로 이루어짐
    
    로고 삽입 완료 ( 추후에 로고 수정 예정)
    footer 완료 ( 후에 따로 footer.jsp를 만들 예정 )	
    
    - 상품 등록, 상품 관리, 작가 등록, 작가 관리 페이지 작성 및 맵핑 메서드 작성
    
    순서 
    
    1. url 맵핑 메서드 작성 - AdminController에 등록, 목록, 작가 등록, 작가 관리 페이지로 접속 가능하게 url 맵핑 메서드 작성
    2. 관리자 페이지 <a> 태그 추가 - 해당 JSP로 이동
    3. 각 페이지 생성 - JSP 생성 
    
    - 작가 등록
    
    영속 계층 - Mapper 관련 (연산 수행)
    비즈니스 로직 - Service, ServiceImpl (등록 로직 구현)
    도메인 모델 계층 - VO , DTO
    
    author 테이블 수정 -> AuthorVO 작성 -> Insert문 테스트 -> AuthorMapper 인터페이스
    -> AuthorMapper.xml -> AuthorMapper.java 메서드 테스트 -> AuthorService 인터페이스
    -> AuthorServiceImpl 
    
    오라클 버전문제로 mapper의 수정이있어야 했음
    https://xzio.tistory.com/354 참고
    
    - 작가 등록 기능 구현 위한 '제어 계층', '프레젠테이션 계층' 작업
    
    제어 계층 -> AuthorController 작성
    	- 뷰 (View) 로부터의 요청 처리하는 url맵핑 메서드 작성
    	
	프레젠테이션 계층 -> authorEnroll.jsp 계층
		- 작가 등록에 사용 될 데이터 입력 및 전송할 수 있도록 작성
		
	<순서>
	
	서비스 단계 테스트 -> url 매핑 메서드 추가 -> 뷰 작성 -> 버튼 작동 스크립트 추가
	-> 작가 등록 성공 경고창 -> 테스트
	
	authorManage 스크립트에 <c:out> 잘 이해 x
	
	${} 를 사용해도 되는데 굳이 <c:out>을 사용하느 이유는 보안성 때문
	
	XSS(Cross-site Scripting)란 ?
	
	-XSS공격은 웹사이트에 스크립트 코드를 주입시키는 방법으로 웹사이트 공격방법 중 기초적인 것
	 해결 방법은 html 코드를 해석하지 않게 만들면 된다. 
	 c:out은 HTML문자를 탈락 시키는 기능도 가지고 있어 많이 사용
	 
	 https://2ham-s.tistory.com/274 참고
	 
	 - 작가 등록 페이지 CSS 설정 추가 & 작가 등록 버튼 유효성 검사 적용
	 
	 enrollBtn 버튼에 클릭하면 '검사 통과 유무'에 대한 js 작성.
	 해당란이 공란이면 span태그에 해당하는 경고문이 나오게 구성
	 
	 - 관리자 페이제에 공통적으로 들어갈 footer.jsp , header.jsp 추가
	 %@include file 태그 이용

-------------- 작가 목록 기능 구현 (authorManage.jsp)-----------------------------
	 
	 - Criteria 클래스 작성
	 지정한 개수와 검색 조건에 따라서 작가 데이터를 출력하는 쿼리를 실행하는데 필요한 데이터들의 모임 
	 
	 - 작가 목록을 반환하는 Mapper 메서드를 활용하여 작가 관리 페이지(authorManage.jsp)페이지에
	  '작가 목록 데이터' 를 표의 형태로 출력하는것이 목표
	  
	 - nationId의 결과를 통해 nationName 값 초기화 하는 로직 작성
	 
	 - authorManage.jsp 페이지에서 페이징 기능을 구현
	   js를 통해 페이징 해당 번호를 누르면 url에 해당 번호에 대한 정보들이 담겨 이동
	   
	   pageMaker 속성 데이터를 통해 '페이지 이동 인터페이스' 를 구현
	   
	   순서는 . 번호 페이지 구현 -> 다음, 이전 버튼 구현 -> 현재 페이지 표시 구현
	   
     - 검색 인터페이스 구현 & 검색 결과 없을 시 뷰 처리
     유효성 검사와 Controller의 코드 수정
     
     
 ------------- 작가 상세 페이지(authorDetail.jsp)구현 -------------------------------- 
 
 	- 작가 관리 페이지에서 작가 이름을 눌렀을 때 작가 상세 페이지로 이동 구현
 	
 	- AuthorMapperTests에서 authorGetDetail 에서 오류 발생
 	
 	getCLOB not implemented for class oracle.jdbc.driver.T4CLongAccessor
 	
 	위의 에러는 오라클에서 Long 타입을 사용했을 때 MyBatis에서 Long타입을 제대로 가져오지 못해서 나는 에러
 	
 	위 에러를 고치기 위해 src/main/resources/mybatis-config.xml 을 생성
 	
 	<typeHandlers>
        <typeHandler handler="com.dustmq.handler.CLOBHandler" javaType="String" jdbcType="LONGVARCHAR"/>
    </typeHandlers>
    
    코드 추가 후 
	
	com.dustmq.handler 패키지에 CLOBHandler.java 생성 후 코드 작성 후 root-context.xml의
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">에 
	<property name="configLocation" value="classpath:/mybatis-config.xml"></property> 를 추가하여 해결
	
	----------------- 작가 수정 페이지 구현 -------------------------------------------------   
	 
	Controller에 수정 페이지 이동 메서드 작성 후 View 처리(authorModify.jsp)
	
	후에 작가 정보 수정에 사용될 쿼리를 실행하는 Mapper 메서드 부터 Service, Controller url 매핑 메서드 순으로 작업
	
	또한 , 작가 정보 수정이 완료되면 '작가 관리 페이지(authorManage.jsp)' 로 이동을 하도록 할 것인데 사용자가 수정이 완료되었음을
	
	알 수있도록 경고창을 띄우는 구문도 구현
	  
    ================================== 상품 등록 ===================================
    
    1. 테이블 생성 ( 싱픔 테이블, 카테고리 테이블 )
    
    카테고리 테이블에서 cateCode의 규칙은 책 상품을 3가지 단계로 분류 할 것이라는 것
    
    1단계 '국내','국외'의 분류
    2단계 '소설','교양','인문','과학','철학' 큰 범주의 책 분야로 분류
	3단계 2단계의 분류에서 좀 더 세분화된 분야의 범주로 분류
	
	위의 cateCode와 더불어 카테고리 테이블(vam_bcate)에 cateName(카테고리 이름) 과 cateParent(상위 카테고리) 와 tier(카테고리 등급) 칼럼으로 구성
	 
	- cateParent는 어떠한 상위 카테고리의 하위 카테고리인지 알 수 있는 역할
	
	- tier은 해당 카테고리 번호가 위에서 분류한 1, 2, 3 단계 중 어떠한 단계인지 표시하는 역할 
	
	2. BookVO 작업
	
	3. Mapper 작업

	4. Service 작업

	5. Controller

	6. View 작업

	7. 테스트
	
	========================================== 위지윅 =========================================
	
	위지윅(WYSYWYG) 에디터란 쉽게 말해 일반적인 사용자가 코드를 몰라도 눈에 보이는 대로 작성할 수 있도록, 
	문서작성 방법을 GUI로 구현한 Tool이다. 
	ex) '한글' 프로그램에 문서를 작성한다던지, 웹카페나 블로그에 글을 쓸 때 사용되는 것이 모두 위지윅 에디터 ( 원래는 코드를 추가하며 한글을 써야함 )
	
	목표 : 책 소개, 책 목차 입력란에 js기반 위지윅 에디터를 적용
	
	CKEditor 이용을 위해 설치 후 에디터 적용
	<script src="https://cdn.ckeditor.com/ckeditor5/34.1.0/classic/ckeditor.js"></script> 를 goodsEnroll.jsp에 삽입
	
	<script> 태그란에 관련 로직 작성
	 
	 
	======================================= 달력 위젯(datepicker)적용 =================================
	
	달력 입력란에는 "yyyy-MM-dd"의 형식으로 반드시 입력. DB에 publeYear(출판일) 컬럼의 데이터 타입이 DATE이기 때문
	
	개발하는 중 의도대로 입력하지 않을 수 있어, 이러한 에러를 보안하기위해 경고글로 입력 형식을 나타내던지, js코드로 형식 유효성 체크를 하는 방법이 있다. 
	
	1. 사용준비 : 코드 삽입
	
		<link rel="stylesheet" href="//code.jquery.com/ui/1.8.18/themes/base/jquery-ui.css" />
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
		<script src="//code.jquery.com/ui/1.8.18/jquery-ui.min.js"></script> 
	
	2. datepicker 적용, CKEditor와 비슷
		
		https://lpla.tistory.com/144 참고
		
		작성 후 한글 변환과 데이터 타입을 변환함 'yy/mm/dd' -> 'yy-mm-dd'
	
	3. 테스트 (성공)
	
	======================================== 상품 등록 - 작가 선택(팝업창) ========================================
	
	authorId <input>태그에 데이터를 넣기 위해 '작가'를 선택할 수 있도록 팝업창을 띄우고, 원하는 작가를 선택하면 팝업창은 닫히고
	<input>태그에 해당 작가의 id값이 입력되도록 하는 것이 목표
	
	1. 작가 선택 버튼 추가 및 css 설정
	
	2. 버튼 작동 구현
	
		developer.mozilla.org/ko/docs/Web/API/Window/open#window_features 팝업창을 띄우는 방법 참고
		
		작가 리스트를 출력하고 검색 기능을 팝업창에서 구현할 것
		
		부모 창 데이터 전달 ( window.opener() )
		
		팝업창의 작가 이름을 클릭하였을 때 팝업창이 닫히면서 부모 창의 작가 <input>태그에 데이터 입력되도록 구현
	
	3. 테스트
	
	
	========================================= 상품 등록 - 카테고리 리스트 =============================================
	
	카테고리 리스트를 JSON 타입으로 뷰(View) 전송, 사용자가 카테고리를 선택할 수 있도록 전송받은 데이터 가공한 뒤 출력하는 방법
	핵심은 어떤 방식으로 카테고리 리스트 데이터를 뷰에 전송하느냐가 관건 ! 
	Jackson은 자바 객체 데이터를 JSON으로 변환시켜주는 라이브러리
	
	1. 카테고리 리스트 객체
	
		CateVO 클래스 생성
	
	2. JSON 데이터 변환
	
		Jackson을 사용하기 위해 pom.xml에 라이브러리 코드 추가
	
	3. 변환 데이터 확인
	
	4. 변환된 데이터를 <select>, <option>태그로 선택할 수 있게 구현
	
	5. 유효성 검사 : 고객이 '상품 등록'을 눌렀을 때 공란이 있는지 없는지 확인 후, 
				  공란일때 해당 공란에 대한 경고 표시와 '상품 등록' 실행을 막는 유효성 검사 구현
				  
				  5-1. span 태그 추가	-> 경고글 역할
				  5-2. 변수 선언
				  5-3. 각 항목 확인	 -> if문 활용
				  5-4. 테스트
				  
    6. 할인율 입력란 인터페이스 & 할인율 입력란 유효성 검사 변경 & 외래 키 설정
    
      6-1.
      할인율 변수는 현재 double 타입으로 소수점을 명시해야 에러가 나지않지만, 편의를 위해 정수로 입력을 받게 변경
      사용자는 정수로 입력하지만 서버에 전송할 때 소수로 변경되도록 구현
      또 사용자가 제품 가격과 할인율을 입력하였을 때 할인된 최종 금액이 얼마인지 볼 수 있도록 구현
      
      할인율은 사용자의 자유로 사용하는 것이기 때문에 값이 입력 되었는지 안되어있는지 확인하는 유효성 검사는 없어도 무방
      대신 사용자가 숫자를 입력해야 하는 입력란에 문자를 입력하지 못하도록 유효성 체크코드로 변경
				  
	  6-2.
	  상품 등록 기능을 완성했기 때문에 개발 편의를 위해서 부여하지 않은 상품 테이블, 작가 테이블 외래키를 부여
	  
	  <순서>
	  1. <span>태그 추가
	  2. 할인가격 출력
	  3. 할인율 유효성 체크 수정
	  4. 외래 키 추가
	  
	  4-1 기존에는 테스트 편의를 위해서 '상품 테이블(vam_book)'의 cateCode, authorId에 외래 키를 추가 x
	      기능을 완성했기 때문에 아래의 명령을 통해서 외래키 설정
	      
	      alter table vam_book add foreign key (authorId) references vam_author(authorId);
		  alter table vam_book add foreign key (cateCode) references vam_bcate(cateCode);
	      
	      외래키 추가 중 에러 발생 :  ORA-02298 cannot validate (string%, string%) - parent keys not found
	      			     원인 : an alter table validating constraint failed because the table has orphaned child records.
	      			     에러 발생 부모의 키 값을 찾을 수 없다. parent가 가지고 있지 않은 데이터를 child가 보유 했을 때 발생
	      			     자식인 vam_book 테이블에 부모 vam_bcate 와 vam_author 에 없는 값을 가지고있어서 나타난 에러 테이블 삭제 후 다시 생성 후 해결
	      			     
	      
  	 ======================================== 상품 목록 페이지 구현 ============================
  	 
  	 상품 목록 페이지에는 '페이징화', '검색'등을 적용할 예정
  	 
  	 <순서>
  	 1. Mapper 메서드
  	 2. Service 메서드
  	 3. Controller
  	 4. View 처리
  	 
     ========================================= 상품 조회 기능 구현 =============================
    
     goodsManage.jsp에서 상품의 이름을 클릭하였을 때 이동하는 조회 페이지를 구현
     조회 페이지에서는 선택한 상품에 관한 등록된 정보가 출력되어야함
     작가 조회 페이지 구현과 동일, 다만 출판일과 카테고리 항목은 신경써야함
     
     <순서>
     1. Mapper
     2. Service
     3. Controller
     4. View
     
     '할인율' 수정 
     현재 할인율은 소수로 출력되는데 사용자가 보기 편하도록 자연수로 출력되도록 구현.
     위 작업은 서버로부터 받아온 할인율 값을 js를 통해 가공하여 할인율 항목에 출력되도록 한다.
     
     '출판일' 처리
     yyyy-mm-dd 00:00:00 식으로 나오고 <fmt:formatDate>를 사용해도 에러가 발생 (ELException)
     formatDate는 Date타입의 데이터를 가공할 수 있는 태그, 현재 BookVO 객체에 있는 출판일은 String 타입이다.(DB에서는 Date타입)
     - 블로거의 실수 , 원래는 둘이 같게 타입을 지정해주어야한다. (수정 필요, 하지만 현재 정보를 주고받는데는 문제가 없어서 진행)
    
    '책 소개', '책 목차' 처리
    CKEditior5를 적용. 적용 후에는 다른 항목들과 마찬가지로 사용자가 수정이 불가능하게 변경해주어야 합니다.
    
    ------------------------------------------- 6 / 27 일 유효성 할인율에서 에러 발생. 일단 주석처리 ------------------------------------
    
    ====================================== 상품 수정 페이지 구현 ===================================
    
    goodsManage.jsp에 수정 페이지로 이동할 수 있는 버튼 구현
    
    '수정 페이지' 에서 출력이 안되는 부분을 구현, '등록 페이지'에서와 마찬가지로 할인율에 따른 예상 가격과 같은 기능들을 구현
    
    <순서>
    1. 출판일	: 출판일을 등록해주어야 하는데 수정페이지는 이미 등록페이지에서 설정했던 DB에 출판일이 적용되어 있음, 이를 변경해주기 위한 추가적인 코드를 적음
    
    2. 책 카테고리 : DB에 저장된 카테고리가 출력 되면서, 대분류에서부터 선택하면서 경우에 따라 다른 하위 분류가 나오도록 초기화 
    3. 책 소개, 책 목차
    4. 할인율
    
    상품 수정 페이지에서 수정 버튼을 눌렀을 때 수정 기능의 동작을 목표
    
    <순서>
    1. Mapper : 수정 쿼리를 수행하는 쿼리문 작업
    
    2. Service
    3. Controller
    4. View
    
    4-1. 버튼 동작	: 취소버튼, 수정버튼 기능 구현
    
    4-2. 유효성 검사
    4-3. 상품 관리(목록) 페이지
    4-4. 테스트
    
    ======================================= 상품 정보 삭제 구현 ======================================
    
    상품 수정 페이지에서 '삭제' 버튼을 추가하여 클릭 시 해당 상품 정보의 삭제를 수행하는 기능 구현을 목표
    
    <순서>
    1. Mapper : 삭제하는 쿼리문
    2. Service
    3. Controller
    4. View
    
    ====================================== 작가 정보 삭제 구현 =======================================
    
    작가 수정 페이지에서 '삭제' 버튼을 추갛하여 클릭 시 해당 작가 정보의 삭제를 수행하는 기능 구현을 목표
    
    <순서>
    1. Mapper
    2. Service
    3. Controller : 여기서 조심해야할 부분이 있다. 삭제하고자 하는 테이블은 작가 테이블(vam_author) 데이터인데, 이 테이블은 외래 키 조건으로 인해 참조하는 상품테이블(vam_book)이 있다.
    				참조되지 않고 있는 행을 지운다면 문제는 없지만 만일, 참조되고 있는 행을 지우려고 시도하면 '무결성 제약 조건'을 위반 한다는 경고와 함께 
    				SQLIntegrityConstraintViolationException 예외가 발생
    				
    				따라서 try-catch문을 사용해 참조되지 않는 행을 지울 땐 삭제를 수행하고 '작가 목록' 페이지로 1을 전송하도록 구현,
    				예외가 발생하는 경우는 '작가 목록'페이지로 2를 전송하도록 구현
	    
    
    4. View
   
   
   ======================================= 상품 이미지 업로드 ==========================================
   
   '상품 등록 페이지'에서 상품 이미지를 업로드 하고 등록한 이미지의 정보를 DB에 저장하는 기능을 구현하는것이 목표
    
    <순서>
    
    1. 전체적인 방향 : 우리의 컴퓨터에 업로드하고자하는 이미지를 저장, 업로드한 이미지의 정보를 DB에 저장
    			   이를 위해서는 '이미지 업로드(저장)', '등록 이미지 정보 DB저장' 크게 2가지의 과정이 필요
    			   
    			   첫 번째로 '상품 등록 페이지'에서 사용자가 이미지를 선택하였을 때 이미지가 업로드(컴퓨터에 저장), 
    			   최종적으로 다른 상품 정보들이 작성된 뒤 '등록 버튼'을 눌렀을 때 '업로드 된 이미지'의 정보가 DB에 저장
    			   
    			   두 번째 '상품 등록 페이지'에서 사용자가 이미지를 선택하고 다른 상품 정보를 다 작성한 뒤 '등록 버튼'을 눌렀을 때
    			   이미지를 업로드하고, 업로드 이미지 정보를 DB에 저장하는 방식
    			   
    			   첫번째 방식으로 구현
    			   
    			   (view) 사용자가 이미지를 선택 -> 선택된 이미지 서버로 전송 -> (server)전송 받은 이미지 저장 후, 저장한 이미지 정보를 view로 재전송
    			   -> (view)전송 받은 데이터를 활용하여 이미지 미리보기, <input>태그에 데이터 저장 -> '등록버튼' 클릭 -> (server)이미지 정보 DB 저장 
    			   
    			   위와 같은 작업을 하려면 'cos.jar', 'commons-fileupload', 'servlet' 등이 있는데 이중 'servlet' 라이브러리를 활용하여 구현
    			   단 , servlet은 3.0 이상부터 가능
    			   
    			   또한, 우리는 페이지의 이동ㅇ벗이 데이터를 서버에 전송하고 반환받아 그 데이터를 사용하기 위해 AJAX를 사용할 예정
    			   
    2. 라이브러리 추가
    
    3. web.xml : web상단의 xml 네임스페이스 2.5 -> 3.1로 변경
    				
    4. multipartResolver 등록 : web 설정은 WAS에 대한 설정이다. 이것만 설정하면 뷰로 전송한 multipart 데이터를 전달받는건 문제없지만, 스프링에서 해당 multipart 데이터를 
    						   처리하는것은 불가능. 그렇기떄문에 MultipartResolver 클래스를 bean으로 등록해주어야 함
    						   MultipartResolver는 파일 업로드 처리를 위해 스프링 프레임워크에서 제공하는 클래스
    						   웹 관련 설정이기 때문에 servlet-context.xml에 설정
    						   
    5. 사용자가 이미지를 선택할 수 있도록 UI를 추가 후, 선택된 파일이 개발자가 허용하는 파일인지 체크하는 것을 목표
    
   	5-1. 업로드 UI 추가
   	
   	5-2. 선택한 파일 접근하기(JS) : input태그를 통해 사용자에 의해 선택된 파일은 File 객체의 형태로 표현, 이 File 객체는 FileList 객체의 요소로 저장
   							  FileList는 배열 형태의 객체이고, 이 요소에는 File 객체가 저장. 즉, 사용자가 input태그를 통해 파일 1개를 선택하면
   							  FileList[0]이란 요소에 File객체에 파일 데이터가 저장됨, 그러므로 사용자가 선택한 파일을 접근하기 위해선 FileList객체
   							  <input>태그의 files속성에 접근해야함. 
   							  접근의 방법은 input태그의 change 이벤트를 통해서 가능
 
   	5-3. 파일 체크(JS)
    
    6. 사용자가 선택한 파일의 File객체를 서버에 전송을 하는 것을 목표
    
    6-1. FormData : 첨부 파일을 전송하기 위해선 FormData 객체를 사용해야함 쉽게 말해 FormData는 가상의 form태그라 생각하면 됨
    				흔히 뷰에 서버로 데이터를 전송하기 위해 form태그를 사용 ( 화면의 이동을 하면서 서버로 첨부파일 전송을 하는 것 )
    				화면의 이동 없이 첨부파일을 서버로 전송 ( FormData 객체를 생성하여 첨부파일을 FormData에 저장하고 FormData 자체를 서버로 전송 )
    				
    6-2. 첨부파일 서버 전송
    6-3. url 매핑 메서드
    
    7. 첨부 파일 저장 폴더 생성
    
   	7-1. 방향 : 럽로드한 이미지가 저장될 폴더를 생성하는 작업을 진행 기본적인 c/upload 경로에 파일을 저장할 것
   	           해당 폴더를 만들어준 후 그 폴더안에 우리가 설정한 용량을 초과하는 파일들을 temp 폴더에 저장되도록 코드를 추가
   
   	7-2. 날짜 경로 문자열 얻기 : 단순히 c/upload 경로에 저장해도 상관은 없지만, 매우 많은 파일들이 한 곳에 업로드 하면 구현할 업로드된 이미지를 호출할 때 upload 폴더 전체를 스캔
   						   그 과정에서 많은 자원이 소모될 수 있기에, 이를 보완하기 위해 업로드 하는 날짜에 맞게 폴더가 생성되고, 생성된 폴더에 업로드 파일을 저장되도록 할 것
   						   SimpleDateFormat 과 Date 를 이용해 현재의 날짜를 원하는 형식의 문자열로 변환할 수 있음
   						   
   	7-3. 폴더 생성(File 객체 사용) : 폴더를 생성하기 위해 File 클래스를 사용, File 클래스의 역할은 Java에서 '파일' 또는 '디렉터리'에 관한 작업을 할 숭 있도록 
   							    여러 메서드와 변수를 제공하는 클래스
   	7-4. 테스트
   	
   	8. 저장된 파일들을 각각 고유하게 관리하기 위해 저장된 파일에 UUID를 추가
   	
   	8-1. 파일 저장 : 뷰로부터 전달 받은 파일을 지정한 폴더에 저장하기 위해서 MultipartFile 클래스의 transferTo() 메서드 사용
   	               전달받은 MultipartFile 객체에 저장하고자 하는 위치를 지정한 File 객체를 파라미털 하여 transferTo() 메서드를 호출
   	               transferTo()의 경우 IOException 과 IllegalStateException을 일으킬 가능성이 있어 예외문으로 처리
   	               
   	8-2. UUID : 듕일한 이름을 가진 파일을 저장하게 되면 기존의 파일을 덮어쓰기 때문에 보완하기 위해 각 파일이 저장될 때 고유한 이름을 가지도록 하며 해결
   	            따라서 파일에 고유한 이름을 가지도록 하기 위해서 기존 파일 이름에 UUID가 포함되도록 할 것
   				UUID 는 JAVA에서 클래스로 사용되고 있고, 5가지 방식 중 랜덤 방식인 randomUUID() 메서드를 사용
   				이 메서드는 static 메서드라 인스턴스화 하지않고도 사용가능
   				UUID.randomUUID()를 통해 생성된 '식별자'는 UUID 타입 데이터 이기 때문에 toString() 메서드를 사용하여 String 타입으로 변경해야 사용 가능
   				
   ============================================= 썸네일 이미지 생성 및 저장 ==================================================
   
   앞으로 저장한 이미지를 호출하여 이미지를 호출하여 홈페이지 화면에 띄우는 것을 구현, 하나의 페이지에 저장된 이미지가 한 개인 경우 크게 문제는 없지만, 
   이미지가 여러 개인 경우 특히 저장된 이미지가 용량이 큰 경우 홈페이지를 운영하는 사람과 홈페이지를 사용하는 사람 모두에게 부담.
   운영하는 사람은 이미지를 많이 호출하는 것은 트래픽 량을 많이 소모하는 원인. 운영자 입장에서는 트래픽 량에따라 비용이 달라지기 때문에 민감한 사항
   
   원본 이미지를 보여주는 것이 아니라 원본보다 크기를 줄인 이미지, 즉 썸네일 이미지를 홈페이지에 보여준다면 이러한 문제점을 다소 보완 가능
   원본은 이미지를 눌렀을 때 이벤트를 통해 볼 수 있도록 구현할 것 
   (Java에서 자체적으로 제공하는 ImageIO를 이용하거나 간단히 썸네일 이미지를 만드 수 있도록 도와주는 scalar, Thumbnailator 등을 이용 )
   위 방법중 ImageIO와 Thumbnailator를 이용해 만들어줄 것
   
   <순서>
   
   1. 방향 : 썸네일의 이미지 이름 -> "s_" + "uuid_" + "원본파일 이름. 이미지 타입"
   
   2. 썸네일 생성 및 저장(ImageIO) : 썸넬을 만들기 위한 ImageIO, BufferedImage, Graphics2D 클래스 사용
   								ImageIO : 이미지를 읽어오거나 생성 할 수 있도록 도와줌 (입출력에 관한 클래스이므로 IllegalArgumentException, IOException 예외를 처리)
   								BufferedImage : 이미지 데이터를 처리하거나 조작에 필요한 값과 메서드 제공
   								Graphics2D : 그림을 그리는데 필요로 한 설정값과 메서드를 제공
   
   3. 테스트
	            
   4. ImageIO 코드 보완, Thumbnailator 라이브러리 적용한 썸네일 이미지 생성 및 저장
   
   4-1. 비율 축소 : 원본 이미지의 크기를 지정한 비율에 따라 축소되도록 보완
   				 
   4-2. 이미지 생성 및 저장(Thumbnailator 라이브러리 사용)
   
   =========================================== 서버 단계에서 업로드 한 이미지의 정보를 뷰로 전송 =======================================================
   
   업로드한 이미지에 대한 정보를 뷰로 반환하는 작업
   
   <고려사항>
   1. 왜 이미지 정보를 뷰로 반환하는가 ? : 업로드한 이미지 정보를 DB에 저장하기 위함. 상품 등록 과정에서 업로드한 이미지에 대한 정보도 함께 저장하기 위함이다.
   								  업로드한 이미지를 사용자가 미리 볼 수 있도록 하기 위해서 
   
   2. 어떤 정보를 보낼 것인가 ? : DB에 업로드 이미지 정보를 저장하는건 결국 이미지를 화면에 출력시키기 위해서이고, 이를 위해 이미지가 저장된 경로와 파일 이름이 필요
   						   뷰로 전송할 이미지 관련 정보는 곧 DB에 저장될 데이터 이기 때문에 이미지 정보를 어떤 방식으로 보관할 것인지 정해야함.
   						 
   						   첫 번째 방법으로는 경로와 파일 이름 전체를 보관 ex) C:\upload\2021\05\13\이미지이름.png
   						 
   						   두 번째 방법으로는 파일 경로와 파일 이름 데이터를 따로 보관 및 관리. 파일 경로는 고정(C:)과 유동(날짜에 영향)이 존재
   						   따라서 이미지에 대한 정보에서 유동적인 경로는 반드시 보관되어야 할 정보
   						   파일 이름은 '썹네일' '원본' 이름을 두 개 보관, 네이밍에 규칙을 안다면 '원본' 이름만 보관해도 무방
   
   						   또 원본 이미지는 '원본 이름' 'uuid'로 나뉘어 진다. 목표 구현은 이미지 출력이기 때문에 세분화할 필요는 굳이 없지만,
   						   만일 홈페이지 사용자가 파일을 다운로드 할 수 있도록 기능을 구현하는 경우, 사용자에게는 uuid가 안붙도록 코드를 작성해야한다.
   						   이 떄 따로 분리하면 편하게 관리 가능
   						   
   						   즉, "고정경로 + 유동경로 + uuid_ + 원본 파일 이름" 으로 보관 
   
   3. 어떤 방식으로 뷰에 데이터를 전송할 것인가 ? : ajax 방식을 사용하고 Controller의 url 매핑 메서드에 @ResponseBody를 사용하거나 메서드의 반환타입을 ResponseEntity를 사용
   										둘 다 서버에서 뷰로 전송하는 Http body에 뷰로 전달하고 싶은 데이터를 포함시켜 보낸다는 것은 동일
   										다른 점은 ResponseEntity의 경우 뷰로 전송될 Http의 세부 정보를 조작하여 뷰로 응답이 가능하다는 점
   										Http의 'status'와 'header'의 속성을 조작 가능
   
   <순서>
   1. 위에 3가지 사항
   2. AttachImageVO	: 이미지에 대한 정보 중 '경로' 'uuid' '파일 이름' 에 대한 데이터를 DB에 보관할 객체 생성
   3. 라이브러리 추가 
   
   4. 서버 단계 이미지 파일 체크, 뷰에 에러 반환 : 이미지 파일 체크 코드가 작동을 하지 않거나 다른 경로를 통해 업로드 url 매핑 메서드를 호출할 경우 
   									    이미지가 아닌 파일도 업로드 될 수 있습니다.
   									    이를 확실하게 파일만 처리하는 메서드가 되도록 업로드를 수행하는 url매핑 메서드에도 전달 받은 파일이
   									    이미지 파일인지 체크를 하는 코드를 추가, 파일이 아니라면 에러 상태 코드를 전송해 경고창이 뜨도록 구현
   									    
   4-1. 방향 : 전달받은 파일이 이미지 인지 아닌지 체크를 하기 위해서 파일의 MIME TYPE 속성을 활용. MIME TYPE는 파일이 어떠한 종류의 파일인지에 대한 정보가 담긴 라벨
   			  Java에서 probeContentType() 메서드를 사용하면 MIME TYPE 반환, ajax에 error 속성을 추가해 경고문까지 뜨게 구현
   4-2. MIME TYPE 데이터 얻기
   4-3. MIME TYPE 체크 및 데이터 반환
   4-4. 뷰 처리
   4-5. 테스트
   
   ====================================== 업로드 이미지 출현 ========================================
   
   비동기 방식으로 url을 호출하면 이미지를 반환해주는 url 매핑 메서드를 구현, 미리 보기 이미지 뿐만 아니라 앞으로 
   사용자가 검색을 하였을 때 볼 수 있는 이미지들을 출력하는데도 사용
   
   <순서>
   1. 방향 : url 메서드의 경우 '파일경로(유동)' + '파일 이름' 데이터를 매개변수로 전달받고, 해당 데이터에 맞는 이미지 파일을 찾아서 뷰에 이미지 데이터를 전송
   		   이미지 파일을 주고받고 싶을 때 데이터 타입은 byte[] 이다. (1byte = 8bit)
   		   ResponseEntity를 사용하여 response 메세지의 body에 이미지 데이터(byte[])를 전송하고 content-type을 명확히 명시
   		   
   2. url 매핑 메서드 작성 및 File 객체 생성 : 이미지는 로그인을 하든 안 하든 모든 곳에서 접근이 가능해야 해서 BookController에 작성
   
   3. Content Type 명시 & 데이터 파일 반환 : ResponseEntity(T body, MultiValueMap<String,String> headers, HttpStatus status)
   									   첫 번째 파라미터는 body에 첨부할 데이터, 두 번째 파라미터는 header의 설정이 부여된 객체를 추가, 세 번째 클래스는 전송하고자 하는 상태 코드와 관련된 코드
   
   4. 테스트 : http://localhost:2994/display?fileName=2022/07/01/c6881be8-a6b4-4e27-b0fd-285718fbaeed_P1235.png 식으로 url을 쳐봐서 확인
   
   5. 작성한 메서드를 활용해 '상품 등록 페이지'에서 업로드한 이미지를 선택하였을 때 미리 보기 할 수 있도록 구현
   
   5-1. 태그 추가 및 css 설정 추가
   5-2. 이미지 출력 메서드 작성 (showUploadImage()) : 이미지는 이미지 업로드 요청 후 성공적으로 업로드 한 이미지에 대한 데이터(유동경로, 파일이름, uuid)들을 전달받았을 때.
    										   따라서 ajax의 success 속성의 콜백 함수에 작성
   
   5-3. encodeURIComponent() 적용 : 파일 이름에 한글이 들어가도 웹 브라우저에서 자동으로 한글 문자를 UTF-8로 변환을 해주었기 때문에 정상적으로 동작. 
   								   하지만 자동으로 인코딩을 해주지 않는 웹브라우저도 존재. 따라서 encodeURIComponent() 메서드를 활용하여 코드를 보완.
   								   encodeURIComponent() 메서드는 다음의 문자 A-Z a-z 0-9 - _ . ! ~ * ' ( )을 제외한 모든 문자를 UTF-8로 인코딩하여 이스케이프 문자로 변환
   								   encodeURIComponent() 메서드는 '/' 와 '\' 문자 또한 인코딩 하므로 replace() 메서드 사용을 안해도 됨
   								   
   ================================================ 이미지 삭제 기능 구현 ==================================================
   
   서버 단계에서 이미지 삭제를 처리하는 url 매핑 메서드 구현 목표
   
   <순서>
   
   1. 방향 : File 클래스의 delete() 메서드 사용. 삭제될 파일을 대상으로 하는 File 객체를 생성하기 위해선 생성자에 대상 파일의 경로인 문자열 데이터를 
   		    매개변수로 부여해야함. 따라서 삭제할 대상의 파일의 경로가 필요로 하기 때문에 url 매핑 메서드에 매개변수로 (fileName)을 받을 것
   		    삭제를 수행하는 url 매핑 메서드는 뷰에서 비동기 방식으로 요청하고 수행 결과를 요청하기 때문에 비동기 요청을 수행하도록 작성 ( ResponseEntity 사용 )
   			
   2. 메서드 작성 : AdminController에 작성. 이미지 파일 삭제를 수행하는 사람은 관리자만 할 수 있도록 하기 위함
   				업로드 당시 이미지 원본 파일과 썸네일 이미지를 생성 및 저장하도록 작성했으므로 썸네일 이미지와 원본 파일을 삭제.
   				원본 파일 대상 File 객체를 생성해주기 위해서 파일 경로 문자열 데이터 필요
   				File클래스의 getAbsolutePath() 메서드 사용하면 대상 File 객체의 경로를 문자열 타입의 데이터로 반환
   				
   3. 삭제 버튼 태그 data 속성 삽입
   
   4. 삭제 메서드 작성 : 미리 보기 이미지 제거 및 서버에 이미지 파일 삭제 요청을 수행하는 코드를 작성. 두 가지 사항에서 적용되어야함
   			   	    첫 번째, 미리보기 이미지의 'x'를 클릭하였을 때 삭제 수행
   			   	    두 번째, 이미지를 삭제하지 않은 상태에서 파일<input>태그를 클릭하여 업로드할 파일을 선택하였을 때 (이전에 있던 파일을 삭제하고 덮음)
   			   	    만일 두 번째 상황에서 파일 삭제를 하지않는다면 두 가지의 파일이 저장되게 되고 미리보기 이미지도 두 가지가 출력. ( 선택된 하나의 이미지만 출력되도록 구현 )
   			   	    
   			   	    작성한 메서드는 '서버에 파일 삭제 요청' -> '서버로부터 응답에 따른 처리'
   			   	    
   			   	    두번 째 방법 적용 x
   
   5. 메서드 적용
   
   6. 테스트
   							    
   =================================================== 업로드 이미지 정보 DB 등록 ====================================================
   
   업로드한 이미지 정보를 상품 등록과정에서 함께 DB에 등록되도록 구현을 목표
   
   <순서>
   1. 테이블 생성 : 이미지 업로드로 인해 생성된 이미지에 대한 정보(uuid, fileName, uploadPath)를 DB에 등록할 수 있도록 테이블을 생성
   				 테이블을 생성하기 앞서 이미지 정보를 등록하는 방식에 대해 간단히 생각해보면 등록하고자 하는 이미지에대한 정보는 상품에 대한 이미지 정보.
   				 하나의 상품에 하나의 이미지만 추가할 것. 그러므로 상품 테이블(vam_book)에 이미지에 대한 정보(uuid, fileName, uploadPath)를
   				 칼럼으로 추가
   				 
   				 뷰에서는 이미지를 하나만 등록할 수 있도록 로직을 구성했지만, 서버에서는 여러개의 이미지를 전달받더라도 처리할 수 있도록 코드를 구성.
   				 따라서 DB 등록 또한 여러 개의 이미지 정보를 등록할 수 있도록 구성해주어야 하는데 상품 테이블에 이미지 정보 컬럼이 있다면 하나의 이미지 정보밖에 처리 못함
   				 이를 보완하기 위해 이미지 정보를 따로 관리 할 수 있도록 새로운 테이블 생성, 이 테이블에 저장될 이미지 정보는 상품 정보에 대한 이미지 정보이기 때문에
   				 bookId라는 컬럼을 추가하여 해당 컬럼은 오직 vam_book의 상품id(bookId)에 존재하는 데이터만 등록할 수 있도록 외래키를 통해 제약사항 추가할 것.
   				 
   
   2. BookVO : 서버의 url 매핑 메서드에서 뷰에서 전송하는 이미지에 대한 정보를 전달 받을 수 있도록 작업
       	  	   현재 상품 등록 url 매핑 메서드 ("/admin/goodsEnroll")의 경우 BookVO 객체 파라미터를 통해서 데이터를 전달 받음
       	  	   상품에 대한 이미지 정보를 BookVO 객체에 포함시켜서 전달 받을 수 있도록 BookVO 클래스를 일부 수정 ( 필요 정보들을 가지고있는 AttachImageVO를 필드 선언 List타입으로 )
       	  	   
   3. <input>태그 추가 : 1. 이미지 정보에 대한 <input>태그는 Js를 통해 동적으로 추가, 등록된 개수만큼 for문을 통해 인덱스를 지정, 이미지 등록 시점에 인덱스를 지정해 주는것이 용이
   
   4. 테스트
   
   5. 이미지의 정보를 서버로 전송하는 작업을 완료했으니 이미지를 등록하는 Mapper 메서드를 작성 후, 기존의 '상품 정보'를 DB에 등록하는 bookEnroll() 메서드에 'bookId'값을 반환하도록
   	  <selectkey> 태그를 추가
   
   5-1. 방향 : 이미지 테이블(vam_image)에 삽입 쿼리를 실행하는 Mapper 메서드 imageEnroll()작성
   			  상품 정보 등록 Mapper 메서드를 호출하는 Service 단계의 bookEnroll() 메서드에서 imageEnroll()메서드를 호출할 것
   			  하지만 '이미지 정보'를 DB에 등록하는 쿼리문(imageEnroll())에는 'bookId'에 관한 데이터가 반드시 필요로 한데(외래 키 설정 때문) 서버로 부터 전달받은 BookVO 객체에는
   			  'bookId'에 관한 데이터가 없다는 점. 'bookId'정보는 DB에 등록하는 과정에서 새롭게 값이 부여되는 'bookId'에 대한 정보가 필요
   			  이를 해결하기 위해서는 imageEnroll() 호출에 앞서서 '상품 정보' 등록인 bookEnroll()을 먼저 호출하고, 해당 메서드에서는 '상품 정보' 삽입 쿼리를 실행하는 동시에
   			  그 과정에서 새롭게 부여되는 'bookId'컬럽 값을 BookVO 객체의 'bookId' 변수에 반환되도록 만들 것 ( bookId 값을 반환 받기위해 MyBatis의 <selectkey> 태그 활용 )
   			  그리고 반환받은 'bookId'정보를 활용해 '이미지 정보' DB등록 처리를 하도록 목표 
   			  
   			  [흐름]
   			  
   			  goodsEnrollPOST()	-> BookVO -> bookEnroll() -> BookVO -> bookEnroll()
   			  	[Controller]				   [Service]  <- BookVO	<-	[Mapper]	(이 과정에서 'bookId' 반환)
   			  										↘
   			  											BookVO의 AttachImageVO
   			  																↘
   			  																bookEnroll()
   			  																 [Mapper]
   			  	
   			  
   5-2. imgEnroll() - Mapper 단계
   5-3. bookEnroll() <selectkey> 적용 - Mapper 단계
   5-4. bookEnroll() 처리 [Service 단계]
   
   5-5. <selectKey> 수정 : 현재의 코드는 <selectKey>의 order가 Before 이어서 insert문이 실행되기 전에 <selectKey> 태그 내부의 쿼리문이 먼저 실행
   					   	  쿼리문의 명령은 'bookId'값 중 가장 큰 값을 찾아서 +1 된 값을 BookVO의 'bookId'에 반환
   					   	  
   					   	  문제는 만약 가장 최근에 등록한 정보를 삭제한 후 , 새로운 정보를 추가했을 때 새로 등록되는 'bookId'와 반환받은 'bookId'가 다르다는 것   
   						  예를 들면 등록한 상품의 bookId 값이 300이 가장 큰 값이 되었는데, 새로운 상품을 등록하기 전 최근에 등록한 상품을 지운다면 가장 큰 값은 299가 된다.
   						  그래서 DB의 자동생성키 기능으로 인해 다음 생성하는 값은 301인데 우리가 작성한 <selectKey> 태그 내부 쿼리 결과는 300이 되어서 일치 x
   						  현재 시퀀스의 값을 알고있는 currval 사용
   						  
   						  이를 해결하기 위해선 제일 최근에 등록된 컬럼 값을 호출해주는 DB의 기능을 사용 ( 업로드 이미지 정보 등록 - 3 에서 해결안된 부분있음 )
   						  select TABLE_NAME, COLUMN_NAME, DATA_DEFAULT from USER_TAB_COLUMNS
						  where TABLE_NAME = 'VAM_BOOK';	(위 쿼리를 실행시 bookId의 DATA_DEFAULT = null 이 나온다)
						  
   6. AdminServiceImpl 에서 코드를 추가하여 상품 등록 및 이미지 등록 처리 기능을 완성하는것을 목표
   
   6-1. Service 코드 작성
   6-2. 테스트
   
   7. 트랜잭션(Transaction) 적용 : 스프링에서의 기능인 트랜잭션은 내부적으로 2개 혹은 그 이상의 작업 단위들로 묶인 메서드가 하나의 단위(하나의 작업이라도 실패 시 모든 작업 취소, 모두 성공시 모든 작업 처리)
   							   처럼 동작할 수 있도록 해주고, 그 결과를 보장해준다. 따라서 여러 예외상황을 대비하기 위한 수많은 코드를 추가하지 않아도 안정된 코드 작성이 가능
   							   
   7-1. 적용하지 않았을 때 문제 : 만일 bookEnroll() 메서드 내부에 동작하는 Mapper 메서드 중 하나에 에러가 발생되면 상품에 등록은 된 상태지만 이미지 테이블엔 데이터가 전달되지 않는다.
   						   즉, 하나만 성공했는데 일부 작업 성공
   
   7-2. 트랜잭션 설정 : pom.xml 추가, root-context.xml에 빈등록 및 어노테이션화 하기위한 코드 추가
   
   7-3. 트랜잭션 어노테이션 적용 : @Transaction 어노테이션만 추가 ( 에러가 자꾸 났는데 pom.xml에 aop관련 라이브러리 추가 후 성공 )
   						    @Transaction은 메서드 또는 클래스에 명시하여 메서드에 대해서 내부적으로 AOP를 통해 트랜잭션 처리코드가 실행되어 AOP가 필요
   
   7-4. 테스트 
   
   
   ============================================== 상품 상세 페이지 이미지 출력 =========================================================
   
   이미지를 등록한 상품의 상세 페이지에서 DB에 저장된 이미지 정보를 활용해 이미지를 출력하는것을 목표
   
   <순서>
   1. 방향 : '/display? 이미지 정보' url을 요청하여 띄울 것. 관건은 '상세 페이지'에 이미지 정보를 어떻게 전달하냐이다.
   			첫 번째는 상품 상세 페이지로 이동할 때 상품에 대한 정보와 이미지 둘다 넘겨주는 것,
   			두 번째는 상품 상세 페이지로 이동후 AJAX 또는 getJSON을 통해서 이미지 정보를 요청하는 것
   			두 번째 방식을 사용하며 '상품 상세 페이지'에서 따로 이미지 정보를 요청하는 방식으로 구현하고 요청 방식은 getJSON을 활용해서 구현
   			getJSON은 GET방식으로 요청 및 응답을 하는 서버로부터 JSON으로 인코딩 된 데이터를 전달받기 위해 사용하는 메서드
   
   2. Service, Mapper : Mpper 클래스는 첨부파일과 관련된 요청만을 처리하는 메서드만을 관리하기 위함 AttachMapper를 추가
   						이미지 등록과 삭제 Mapper 또한 AttachMapper에서 관리하도록 하는것이 좋지만 일단 넘어감
   					
   3. Controller
   
   ================================================ 상품 이미지 수정 ==================================================
   
   상품 수정 페이지에서 이미지가 출력되도록 기능을 구현, 이미지 수정의 기능 구현
   
   <순서>
   1. 방향 : 수정 페이지에서 기존의 상품 이미지가 없다면 새로운 이미지 등록, 기존의 이미지가 있다면 새로운 이미지를 등록 후 '수정 버튼'을 누르면 새로 추가하거나 수정해준
     	    이미지가 DB와 서버에 저장되는 것. 즉 기존의 이미지 데이터를 삭제하고 추가해주는 작업.
     	    크게 이미지 수정을 '이미지'가 저장되는 서버와 '이미지 정보'가 저장되는 DB 2가지 측면으로 생각
     	    
     	    1-1. DB : 첫 번째는 vam_image 테이블에서 삭제할 이미지를 하나하나 찾아 새로 추가할 이미지 정보가 담긴 행을 추가해주는 것.
     	    	      두 번째는 vam_image 테이블에서 수정하고자 하는 상품과 관련된 행을 모두 지우고 새로 추가 할 이미지 정보와 기존에 존재 해야할 이미지 정보가 담긴 행을 추가
     	    	      두 번째 방식은 뷰에서 삭제할 이미지 정보를 별도로 전달받지 않고 수정할 대상 상품과 관련된 이미지 정보를 모두 지워준다.
     	    	      그 다음 기존에 존재해야 할 이미지 정보와 새로 추가한 이미지 정보를 뷰로 전달받아 테이블에 행들을 새롭게 추가
 	    	      
 	    	     서버 : 첫 번쨰 방식은 서버에서의 이미지 삭제와 이미지 추가 작업을 '수정 버튼'이 눌렀을 때 이루어 지게 하는 것
 	    	    	   두 번째 방식은 사용자가 수정을 하는 과정에서는 서버에 저장된 파일에 대한 삭제 작업은 전혀 하지않고 추가 작업만 해주는 것
 	    	    	   대신 서버 내에서 주기적으로 DB에 등록된 이미지 정보와 서버에 저장된 이미지를 비교하여 DB에 등록되지 않은 이미지가 있다면 해당 이미지들만 삭제
 	    	    	   위 두 번째 방식은 배치 프로그램을 사용하여 구현 가능
 	    	    	  
	     		 뷰(상품 수정 페이지) 
	     		 
	     		 - 기존에 저장되어 있는 이미지가 있다면 사용자가 볼 수 있도록 출력, 더불어 기존 이미지에 대한 정보가 담긴 <input>태그가 작성
	     		 - 출력된 이미지에는 삭제 버튼 존재
	     		 - 삭제 버튼을 누르면 서버에 저장된 이미지에 대한 삭제를 서버에 요청하지 않고 단순히 이미지가 출력이 되는 태그와 이미지 정보가 담긴 <input>태그만 삭제
	     		 - 사용자가 새로운 이미지를 추가하면 서버에 이미지 저장 요청, 서버에서는 이미지 저장 후 이미지 테이블을 뷰로 다시 반환, 뷰는 반환 받은 이미지 정보를 통해서
	     		   이미지가 출력이 되도록 태그를 추가하고 반환 받은 데이터를 저장한는 <input>태그가 저장되도록 함
	     		 - 수정 버튼을 누르면 수정된 상품 정보와 함께 서버에 존재해야 할(<input>태그에 작성된) 이미지 정보를 서버로 전송
	     		 
	     		 서버
	     		 
	     		 - 뷰에서 이미지 저장 요청이 있을 경우 서버에 이미지를 저장하고 해당 이미지 정보를 뷰로 반환
	     		 - 뷰에서 수정 요청이 들어오면 전달받은 수정되어야 할 상품 정보와 이미지 정보가 담긴 BookVO 객체를 통해 수정 작업을 수행
	     		 - 먼저 상품 정보에 대한 수정 작업 후 상품 이미지 정보 수정 작업을 진행
	     		 - 상품 이미지 작업은 관련 이미지 정보를 모두 삭제 후 뷰로부터 전달받은 이미지 정보를 등록 
	     		 
	     		 
 	2. 이미지 수정 페이지에서 이미지를 삭제, 등록하는 작업을 목표
 	
 	<순서>
 	
 	1. 삭제 버튼
 	2. 이미지 등록
 	3. 정리
 	
 	3. 이미지 수정 서버 처리 작업
 	
 	view로 부터 전달받은 수정된 상품정보와 이미지 정보를 DB에 반영되도록 하는 것을 목표
 	
 	<순서>
 	
 	0. 수정페이지 이미지 추가 코드 수정
 	1. 방향
 	2. 이미지 정보 삭제 Mapper
 	3. goodsModify 메서드 수정
 	
	================================================== 배치 프로그램 이해 및 적용을 위한 환경 설정 ====================================================
	
	현 상태에서 사용자가 수정을 할 경우 서버의 첨부물 저장폴더에는 수정을 하기 전 저장했던 이미지, 또는 사용자가 수정 페이지에서 이미지를 추가하였다가 취소한 이미지가 남아 있게 된다.
	이러한 이미지는 DB에 정보가 저장이 되지 않는 이미지이다. 따라서 삭제를 해주는 Batch Program을 적용해 지정한 시간에 DB에 없는 이미지 파일들을 삭제. 	
	
	1. Batch Program : 최종 사용자의 개입 없이 실행을 스케줄링할 수 있는 작업(job)의 실행을 의미. 즉, 수행되어야 할 어떤 '작업'을 실시간으로 바로바로 수행하는 것이 아닌, 
					   지정한 시간에 일괄적으로 작업을 처리하는 것을 말한다. 
					   보통 주문 앱에서 주문 정보를 DB에 저장하는 작업을 예로 들 수 있는데, 인기가 많으면 분당 수 만 건의 주문 요청이 있을 수 있다.
					   이러한 정보들을 실시간으로 DB에 저장을 하게 되면 너무 많은 자원이 불규칙적으로 소모되어야 한다. 따라서 이러한 정보들을 임시 저장소에 저장했다가 
					   지정한 시간에 주기적으로 지정한 수만큼 데이터를 DB에 저장하는데 활용
					   'Spring Batch' , 'Quartz' 등이 있는데 Quartz 사용
				    
    2. 환경 설정 : pom.xml에 Quartz 라이브러리 추가, 스케쥴링 사용을 위한 'xml설정' , '어노테이션설정' 두 가지 방식이 존재 
    			task 패키지를 새로 만듦( 배치 작업 처리만 전담 ), root-context.xml에서 설정 추가
    			
	=========================================== DB에 정보가 존재하지 않는 이미지 파일 삭제 작업 구현 =====================================================
	
	배치 프로그램을 사용하고자 하는 이유는 서버 내부에서 주기적으로 DB에 이미지 정보가 존재하지 않는 이미지 파일을 삭제하기 위함.	
	
	1. 방향 : DB에 정보가 없는 이미지 파일을 삭제하기 위한 전체적인 방향
		
	1-1. DB에 존재하는 이미지 정보 리스트를 가져온다
	1-2. 서버에 저장된 이미지 리스트를 가져온다.
	1-3. 두개의 리스트를 비교해 DB리스트에 존재하지 않는 서버 이미지 리스트를 분류
	1-4. 해당 리시트의 이미지 파일을 삭제
	
	체크할 파일의 범위는 현재 서버에 저장된 이미지 파일들은 파일이 저장된 날짜 값을 이름으로 가지는 디렉토리에 저장되어있고, DB에 저장된 이미지 정보 또한 저장된 날짜 값을 가지고 있다.
	따라서 하루 단위의 이미지 파일들을 체크할 대상으로 상정. 정리하면 DB에 저장된 어제자 날짜의 이미지 정보 리스트를 가져오고, 어제자 날짜에 저장된 이미지 파일들의 리스트를 가져온다.
	두 리스트를 비교해 DB리스트에 존재하지 않느 서버 이미지 리스트를 분류하여 해당 리스트의 파일들을 삭제
	
	지정된 날짜에 등록된 행들을 반환하기 위해서 명령문의 where 조건문에 vam_image 테이블의 uploadPath 컬럼값을 지정된 형식("/")으로 어제 날짜 값을 부여해야함.
	Oracle에선 "TO_CHAR"을 사용하면 됨
	
	2. DB에 저장되지 않은 이미지 파일 삭제 구현
	
	2-1. 코드 테스트(DB 이미지 파일 리스트) : 어제 날짜로 저장된 이미지 정보를 변수에 할당하고,
									 DB에 저장된 리스트와 비교해야 하므로 자료형을 List<Path>로 하고
									 Path 객체를 선언하고 DB에 저장된 정보들을 반환해주고 
									 List타입인 checkFilePath의 요소에 저장.
									 DB에서 가져온 이 checkFilePath는 서버에 저장된 이미지 파일을 삭제할지 말지의 기준이 되는 데이터이다
									 
									 하지만 현재 우리는 이미지를 저장할 때 썸네일 이미지도 같이 생성되도록 구현했기 떄문에, 현재 checkFilePath 데이터를 기준으로
									 삭제하게 된다면 삭제하면 안될 쌈네일 이미지 또한 삭제.
									 
									 해서 위와 같은 방법으로 썸네일 이미지 정보도 추가 해야한다. "s_" 만 붙여주면 됨
									 
									 
	2-2. 코드 테스트(디렉토리 이미지 파일 리스트) : 서버 디렉토리에 저장된 이미지 파일의 리스트를 얻으려면 "listFiles()" 메서드 활용
										 디렉토리 File객체에서 listFile()를 호출하면 해당 디렉토리에 저장되어 있는 파일들을 File객체로 생성하여 요소로 가지는 배열을 반환
										 따라서 대상 디렉토리 File 객체를 얻어야 하는데 Paths 클래스의 get() 메서드를 사용해 
										 해당 path를 얻은 후, toFile() 메서드를 호출해 Path 객체를 FIle 객체로 변환할 것  
	
	
	2-3. 코드 테스트(삭제 대상 파일 분류) : 위 작업들로 얻어낸 'DB 파일 리스트' , '디렉토리 파일 리스트' 를 서로 비교하여 삭제되어야 할 파일의 리스트를 분류
								 	removeFileList에는 디렉토리에 저장되어 있는 파일이 모두 담겨있다. 
								 	targetFile 과 checkFilePath 와 비교를 통해 동일한 데이터를 가지는 File 객체 요소를 제거함으로써 DB에 정보가 저장되지 않은 이미지 File 객체만 남김
								 	
	


	2-4. 코드 테스트(분류된 파일 삭제) : 삭제되어야 할 File 객체를 얻었으니 이젠 File클래스의 delete() 메서드를 호출해 해당 파일을 삭제 구현
	
	3. 위 테스트 코드를 활용해 최종적으로 하루에 한 번 일괄적으로 DB에 정보가 존재하지 않는 이미지 파일을 삭제하는 코드를 작성
	
	3-1. Batch 작업 클래스
	3-2. 이미지 파일(DB존재 x) 삭제 코드 작성
	3-3. 테스트
	
	=========================================== 이미지가 있는 상품 정보 삭제 시 발생하는 에러 해결 =====================================================
	
	이미지 정보가 없는 상품의 정보는 삭제가 정상적으로 작동하지만 이미지를 가지고 있는 상품 정보를 삭제 시 에러 발생 해결을 목표
	
	1. 에러 이유 : "무결성 제약조건"위반으로 인해서 발생되는데 이는 'vam_image' 테이블의 "bookId" 컬럼이 'vam_book' 테이블의 "bookId" 컬럼을 참조하도록 외래키를 설정했는데
				이는 현재의 상품 정보 삭제는 'vam_book' 테이블의 지정된 한 행을 삭제하도록 되어있다. 해당 상품에 이미지가 있는 경우, 'vam_image'의 하나 혹은 둘 이상의 행들이 존재하고
				이 행들은 'vam_book' 테이블의 하나의 행을 참조하고 있는 상태.
				즉, 'vam_book'의 테이블 행을 지우게 되면, 'vam_book'테이블을 참조하던 'vam_image' 행들이 참조할 수 있는 값이 없어져 에러가 발생
				
	2. 방안  : 이러한 에러를 고치기 위해 참조하고있는 테이블을 먼저 삭제하거나 같이 삭제하는 방법이 있다.
			  첫 번째 방식으로 'vam_image' 테이블의 행을 삭제한 뒤 'vam_book' 테이블의 행을 삭제
			  서버에 저장되어있는 이미지 파일의 삭제도 해야한다. 배치 프로그램을 설정해놓았지만 그 코드는 어제자 파일만 대상으로 삭제가 되도록 구성.
			  따라서 해당 상황에 적용될 배치프로그램을 작성하거나, 상품 정보가 삭제될 때 같이 서버의 이미지 파일도 삭제되도록 한다.( 후자의 방식을 선택 )
			  즉, 기존 '상품 정보 삭제'를 하게 되면 상품에 대한 정보만 삭제되었는데, 이미지 기능이 추가됨에 따라 '상품 정보' , 'DB에 저장된 이미지 정보' , '서버에 저장된 이미지 파일' 을 삭제해야함 
	
	3. 방향 : 기존의 상품 삭제 메서드 (goodsDeletePOST)를 활용해 진행, 서버에 저장된 이미지 파일 삭제 후 DB상품 정보 삭제, DB에 저장된 이미지 정보 삭제
	
	4. 서버 파일 삭제 : 파일을 삭제하기 위해선 이미지 파일에 대한 정보가 필요. 'bookId' 데이터를 활용해 상품 이미지 정보를 DB로부터 가져올 수 있도록 Mapper, Service 작업	
	
	5. DB 데이터 삭제 ( 상품 정보, 이미지 정보 ) : '상품 정보 삭제'를 담당하는 Service 메서드에 '이미지 정보 삭제' 에 대한 작업도 수행하도록 만들 것.
										  '이미지 정보 삭제'는 Mapper 메서드에 deleteImageAll() 메서드를 사용
										  
   
	=============================================== 검색 기능 ==================================================
	
	'책 제목' '작가' 검색 가능하고 , 메인 페이지에서 각 카테고리가 출력되어 있는 네비 링크를 클릭 시 해당 카테고리의 상품이 검색이 될 수 있게 하도록 구현
	
	'기본적 검색 기능 구현' -> '조건 검색 기능 구현(작가, 카테고리 검색)' -> 메인페이지 카테고리 네비 링크 순으로 구현
	
	<순서>
	
	1. 방향 : 검색 기능은 크게 View , Server 측면에서의 역할
			
			* View : 사용자가 작성한 keyword에 대한 데이터와 더불어 검색 결과 페이지에 몇 개의 결과물들을 표시할 것인지(amount), 몇 번째 페이지를 볼 것인지(pageNum)에 대한 
					 데이터를 서버에 전송. (amount 와 pageNum을 지정하지 않으면 10,1 값이 서버 측에서 기본으로 설정) 
					 
																↓
					 
			* Server : 서버는 전달받은 keyword, amount, pageNum을 사용해 DB에서 검색 결과 데이터를 가져온 뒤 클라이언트에 전송하고,
					   결과화면에 페이지 정보를 출력하기 위해 필요로 한 데이터들을 또한 같이 생성하여 전송	
					   
					   											↓
					   											
			* View : 전달받은 데이터들을 활용해 검색 결과 목록을 출력하고, 몇페이지에 대한 정보들을 출력	 
			 
	
	2. 서버
	
	2-1. Mapper	: BookMapper.java 생성. 검색 결과에 대한 데이터를 처리하는 메서드와 페이징 데이터를 처리하는 메서드를 구현
				  BookMapper.xml 생성
	
	2-2. Service
	2-3. Controller
	
	3. 뷰
	
	4. 테스트
	
	===================================== 조건 검색을 위해 기존 검색 쿼리를 동적 쿼리로 변환 =============================
	
	책 제목에 관해서만 검색이 되도록 구성되어있는데, '작가 검색', '카테고리 검색' , '카테고리 + 책 제목' , '카테고리 + 작가' 구현 추가			
		
	<순서>
	
	1. 방향 : 검색 조건에 맞는 쿼리문을 모두 일일이 작성하고 사용자가 요청하는 조건에 따라 해당 쿼리문을 요청, 이 방법은 단순하지만 메모리가 낭비되고, 코드를 관리하기 어려움
			 조건당 바뀌어야 할 쿼리문은 bookName like '%' || #{keyword} || '%' and 에서 조금씩만 바뀐다.
			 일부분의 코드만 바꾸기 떄문에 이를 해결하기 위해 MyBatis에서 제공해주는 기능을 사용해 쿼리문이 상황에 따라 동적으로 변경되도록 변경할 것
			 정적 쿼리문은 판단의 근거가 되는 데이터를 활용하여 Service 혹은 Controller 에서 필요한 쿼리문을 요청했지만,
			 동적 쿼리문은 판단의 근거가 되는 데이터를 직접 쿼리문에 넘길 것
			 
 	2. Criteria 객체에 String[] authorArr (작가 리스트) , String cateCode (카테고리 코드) 를 추가
 	
 	3. Mapper 메서드 : '작가 검색'을 위해 필요한 authorId 정보를 만들어 내는 Mapper 추가. 사용자가 자신이 원하는 작가의 '이름'을 작성하여 서버로 보냄.
 					 vam_book 테이블에 authorName의 컬럼이 있다면 기존 검색 쿼리에 전달받은 '이름' 데이터를 그대로 사용하면 되지만, authorName이 없고 authorId
 					 로 변환해주는 작업을 해주는 Mapper 메서드 작성
 					 작성해줄 Mapper 메서드의 반환 결과로 전달받은 데이터를 Criteria의 authorArr 변수에 저장할 것.
 					 authorArr은 String[] 로 선언을 했는데 이는 authorId가 한 개 이상일 수 있기 때문이다. 동명이인일 수 있고, "ABC" 를 찾으려 "AB"만 입력해도
 					 "AB"가 포함된 많은 데이터를 반환할 수 있다.
	
	4. 동적 쿼리 : BookMapper.xml에 <sql>태그 수정. <trim> 태그 추가
					
				* <trim> . prefix : 실행될 쿼리의 <trim>문 안에 쿼리 가장 아에 붙여줌
						 . prefixOverride : 실행될 쿼리의 <trim>문 안에 쿼리 가장 앞에 해당하는 문자들이 있으면 자동으로 지워줌
						 . suffix : 실행될 쿼리의 <trim>문 안에 쿼리 가장 뒤에 붙여줌
						 . suffixOverrides : 실행될 쿼리의 <trim>문 안에 쿼리 가장 뒤에 해당하는 문자들이 있으면 자동으로 지워줌
	    					
		*	typeArr의 요소로 존재하는 'A', 'C', 'T' 값들은 그 값 자체로 쿼리 코드 #{type} 으로 출력되는 것이 아니라 쿼리 코드가 실행되는 조건 
				    
    5. 테스트
    
    <순서>
    
    5-1. 테스트(Junit) : 각 조건의 식으로 실험
    
    5-2. 문제점 및 보완 : 하지만 테스트 결과 중 의도하지 않은 결과가 나오는 코드들도 존재. 책 제목, 카테고리 검색 조건은 맞지않으면 결과가 없는데
    				  작가 검색은 검색 조건과 상관없는 데이터들이 뜸. 이는 작가 정보의 경우 getAuthorIdList() Mapper 메서드로부터 반환받은 데이터를 활용해
    				  동적 쿼리에 사용되는데 작가 정보가 없는 경우 요소가 없는 빈 배열 객체가 MyBatis 쿼리문에 전달되어 작가 조건문이 추가되지 않은 쿼리문이 사용
    				  조건 없이 데이터를 반환하게 된다.
    				  이러한 문제를 고치기 위해 BookServiceImpl의 getGoodsList() 메서드의 구현부를 수정.
    				  만일 type = 'A' 가 들어가 모든 경우의 조건에서 검색했을 떄 검색 결과가 없다면 아무것도 들어있지 않은 빈 요소의 ArrayList를 새로 생성하고 반환
    				  
    5-3. 뷰 처리 및 테스트 : 관리자 모드가 아닌 일반 main.jsp에 코드 추가
	     		  
	===================================  상품 목록 화면 구현 ======================================
	
	검색을 검색 기능을 토대로 나온 결과값을 볼 수 있는 '상품 목록 화면(search.jsp)'로 전달.
	search.jsp의 css 설정을 추가
	
	<순서>
	
	1. main.jsp css 설정 추가

	2. 상품 목록 화면(search.jsp)
	
	2-1. 기본 틀 : search.jsp 에서 틀 추가, search.css 추가로 디자인
	
	2-2. 검색 결과 유무 : 검색란에 DB에 저장되지 않은 keyword를 치면 search.jsp에서 검색결과가 없습니다. 라고 뜸
	
	3. 검색 쿼리 컬럼 추가 : BookMapper.xml 파일의 getGoodsList의 select문에 bookDiscount 추가
	
	4. 검색 결과 데이터 & 페이지 이동 이동인터페이스 : 예전에 했던 작업과 동일하게 작업하고 js 작성부에 var 변수가 아닌 const 로 선언
										  var는 function-scoped 이고  let, const는 block-scoped 이다.
										  
										  javascript는 변수 선언이 런타임에서 되는것이 아니라, 그 이전 단계에서 먼저 실행되어 
										  소스코드를 한 줄씩 순차적으로 실행하기 앞서, 변수 선언을 포함한 변수 선언문, 함수 선언문 등을 찾아내
										  먼저 실행한다. 다시 말해서 변수 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행되는 특징을 호이스팅(hoisting)이라 한다.
										
										  자바스크립트에서 모든 코드 블록(if, for, while, try/catch등) 이 지역 스코프를 만들고 이러한 특성을 block-scoped 이다.
										  하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정. 이를 function-scoped 이라 한다.
										  
										  var 키워드의 문제점
										  
										  * 변수 중복 선언 가능하여, 예기치 못한 값을 반환할 수 있다.
										  * 함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 된다.
										  * 변수 선언문 이전에 변수를 참조하면 언제나 undefined를 반환한다.
										  
										  
										  함수가 아닌 곳에서 var 키워드를 사용하면 전역 변수로 취급한다. 위 문제 점을 보완하기 위해 
										  
										  1. 변수 중복 선언 불가
										  
										  1-1. let : 변수 중복 선언이 불가, 재할당은 가능, 선언단계와 초기화 단계가 분리되어 진행
										  
										  1-2. const : 반드시 선언과 초기화를 동시에 진행해야함, 재선언과 재할당 불가(재할당의 경우 객체는 가능)
	5. 테스트
	
	6. 출력 데이터 형식 변경 : 가격과 출판 날짜를 <fmt>태그를 사용해 형식을 변경
	
	7. 상품 목록 화면에서 이미지 출력 : 해당 상품에 대한 이미지를 출력, 이미지가 없다면 '이미지 없음' 을 뜻하는 이미지를 출력
			
	js 설명
	
	1) $(선택자).each(function(i,obj)); : 선택자로 지명된 태그가 여러 개일 경우 $(선택자)를 통해 해당 태그 객체를 호출하게 되면, 해당 선택자를 가지는 모든 태그가 담긴 객체가 반환
										이 객체에 each(function) 메서드를 호출하면 동일한 선택자를 가진 모든 태그 객체를 순회, each메서드의 구현부에 작성된 코드 실행
										i는 순회하면서 실행될 때 index고 obj는 그 순서에 해당하는 객체
	
	2) $(선택자).data("속성명"); : 태그에 데이터를 심기위해 data-속성명 = '속성값' 으로 작성했는데, 작성해둔 속성값을 얻기 위해 사용하는 메서드가 data() 이다.
	
  	======================================== 메인 페이지 상품 이동 네비 구현 =========================================
  	
  	상품 네비 기능
  	
  	<순서>
  	
  	1. 구현 방향 : 카테고리들이 나열되어 있을 때 사용자가 원하는 카테고리 이름을 클릭하였을 때 해당 카테고리들로만 구성된 상품의 목록 페이지로 이동
  				해당 기능을 구현하려면 '서버' 와 '뷰' 에서 각각 처리해줘야 할 것이 있다.
  	
				* 뷰
				- 사용자가 메인페이지에 들어 갔을 때 상품의 카테고리 데이터들이 나열
				- 사용자가 원하는 카테고리를 클릭하면 해당 카테고리 정보를 서버로 전송해 관련 상품들의 리스트를 요청
				- 서버가 관련 데이터를 반환해주면 해당 데이터를 사용자가 보기 편하도록 출력
				
				* 서버
				- 뷰에서 전송한 카테고리 정보를 활용해 DB에 관련 상품 데이터를 요청
				- DB로부터 요청한 정보를 반환받으면 뷰에 응답하면서 정보를 전송
				
	2. 네비 태그 : 사용자가 카테고리를 볼 수 있도록 데이터들을 볼 수 있게 틀을 만듬 Hover DropDown 스타일 사용
				main.css 추가. main.jsp 네비 부분에서 해당 텍스트를 눌렀을 때 해당 상품이 나열되도록 a태그 작성
				하지만 모든 카테고리 코드를 추가해주면 너무 많고, 변동이 있을 시 매번 수정해야해서 이를 보완하기 위해
				서버로부터 카테고리 리스트 정보를 요청하고 main.jsp가 렌더링 될 때 동저긍로 카테고리<a> 태그들이 추가할 것 
				<a>태그에는 카테고리 개수만큼 추가해야하는데 <a>태그는 "/search?type=C&cateCode=${cateCode}" 인데
				/search의 url로 넘겨질 cateCode 데이터와 사용자에게 보여줄 cateName 입니다.
				
				<흐름>
				
				BookController -> Service로 -> Mapper로 DB에 각 카테고리의 'cateCode'와 'cateName'에 대한 데이터 요청을 하고,
				카테고리 데이터가 담긴 List객체로 반환받는다. 요청한 데이터는 하나의 카테고리가 아니라 여러 개의 카테고리 데이터.
				그러므로 'cateCode'와 'cateName'의 변수를 가지고있는 CateVO객체에 담고 이 객체를 List 자료구조에 담아서 반환되도록 작성
				전달받은 List에 담긴 카테고리 데이터들을 뷰로 전달하고 <c:foreach>태그를 이용해 <a> 태그가 출력되도록 만들 것 
				
	3. BookController : mainPageGET() 메서드에서 매개변수로 Model을 추가해 반환받은 결과를 main.jsp에 전달			
					  
					  
  	================================================ 검색 필터링 기능 구현 ============================================
  	<검색 필터링 구현 포기>
  	상품 목록 페이지로 이동하면 그 위에 세부적으로 검색된 결과물을 필터링하는 인터페이스를 만드는 것
  	
  	<순서>
  	
  	1. 구현 방향 : 크게 두 가지 측면에서 작업이 이루어져야함. 첫 번째로는 사용자가 어떤 필터링을 할 수 있는지에 대한 정보를 뷰에서 만들고
  				 뷰에 전달해 사용자가 볼 수 있도록 인터페이스 추가, 두 번째로는 사용자가 필터링 인터페이스를 눌렀을 때 필터링된 검색을 수행할 수 있는 서버 측 메서드 작성
  				 "/search" 매핑 메서드에서 추가적으로 코드 작성. 이후 테스트에선 기능의 작동확인을 위해서 아래와 같은 경우의 수로 테스트 진행 
  				  '책 제목', '작가 검색', '카테고리 검색'과 더불어서 '책 제목 + 카테고리 검색', '작가 + 카테고리 검색'을 진행
  				  
  				  즉, 진행해야하는 주 작업은 사용자가 자신이 검색한 상품 목록이 속한 카테고리 리스트를 볼 수 있도록 서버에서 데이터를 만들어내고 뷰에 전달,
  				  뷰에선 사용자가 이 데이터를 필터링 페이지로 이동할 수 있도록 인터페이스 추가
  				  이런 인터페이스에는 필요한 데이터는 '카테고리 코드 번호(cateCode)' 와 '카테고리 이름(cateName)' 이다
  				  cateName은 사용자가 보이는 시각적인 부분을 위해서이고, cateCode는 "/search" url의 cateCode 파라미터 값으로 보내기 위함
  				  그 후 사용자가 검색한 키워드를 상품이 속한 카테고리 몇 개의 상품이 있는지에 대한 '데이터의 개수'이다.
  				  검색 결과 몇개의 상품이 나왔는지 알 수 있게 하는 역할.
  				  
  				  정리하면 '카테고리 이름', '카테고리 코드', '검색한 데이터의 개수' 의 데이터들이 필요
  				  
  				  BookMapper.xml에서 join문을 이용 ( 두 테이블을 서로 연결 )
  				  
  				  outer join : 조인 조건에서 동일한 값이 없는 행도 반환할 때 사용하는 구문. 
  				  	(합집합)	   즉 A, B 테이블을 join할 경우, 조건에 맞지 않는 데이터도 표시하고 싶을 때 OUTER JOIN을 사용
  				  			   USING, ON 조건절을 필수적으로 사용.
  				  			   
  				  			   USING : 조인하는 테이블 내에 있는 컬럼들이 동일한 이름을 가지고 있을 때 사용 가능
  				  			   ON : 두 테이블을 연결할 조건을 명시(일치 조건을 입력)
  				  			   
	  			  LEFT OUTER JOIN : A 테이블에 LEFT OUTER JOIN B 하는 경우
	  			  				    A,B 테이블의 조인 조건이 맞는 경우 B 테이블의 컬럼에서 해당 데이터를 가져오고,
	  			  				    조건이 맞지 않는 경우 각 테이블의 컬럼중 A테이블의 컬럼은 무조건 결과값에 포함되어 나오고 
	  			  				    B테이블에서 가져온 컬럼은 NULL로 채운다.
	  			  				    
		    	  RIGHT OUTER JOIN : LEFT OUTER JOIN과 반대됨 B 테이블이 기준이 되어 결과를 보여줌
		    	  
		    	  FULL OUTER JOIN : A 와 B 테이블의 데이터를 모두 읽어 중복된 데이터는 삭제한 JOIN 결과를 보여줌
  				  
				  만일 조인 조건으로 매칭되는 데이터만 보고 싶으면 INNER JOIN을 사용
				
   				  https://doorbw.tistory.com/223 참고
   
   ========================================= 상품 상세 페이지 ========================================
	
   상품 검색 페이지나 다른 경로를 통해 이동할 수 있는 '상품 상세 페이지' 구현 목표
   
   * 서버측
   
   <순서>
   
   1. 방향 : 관리자 페이지에서의 '상품 상세 페이지'와 다르지 않지만 위 상세페이지에선 @PathVariable 어노테이션 사용
   			처음 구현했던 관리자의 상품 상세 페이지 url 경로를 보면 "/admin/goodsDetail"이다
   			지정한 상품의 상품 페이지로 들어가려면 "bookId" 값을 쿼리스트링에 ?를 추가하고 K = V 로 지정했다.
   			@PathVariable 어노테이션을 사용하면 쿼리스트링으로 값을 주지 않아도 url 경로에 삽입 가능
   			
   2. Mapper : 클라이언트가 상품 상세 페이지 요청을 하면, 사용자가 지정한 상픔의 정보가 포함된 상품 상세 페이지를 전송해야함
   			   BookVO 지정한 멤버들을 사용해 값을 할당하고 뷰로 전송할 것
   			   MapperTest중 reflectionexception there is no getter for property named ... 에러 발생
   			   알고보니 Mapper.xml에 #{bookId}를 ${bookId}로 적음
   			   Reflector 클래스가 resultType 의 클래스에 대한 필드정보와 getter/setter의 매핑 정보를 만들어 두고
   			   이를 통해서 바인딩 시 해당 필드를 찾는다.
   			    
   3. Service : getGoodsInfo() 메서드가 반환해준 BookVO 객체에 이미지 정보 데이터들을 추가할 것
   				그러기 위해선 imageList 변수에 값을 부여 . 이미지 정보를 호출하는 AdminMapper에 getAttachInfo()와 똑같이 작업
   				
   4. Controller : @GetMapping("/goodsDetail/{bookId}"), 을 매핑으로 작성하고
   				   메서드의 매개변수에 (@PathVariable("bookId")int bookId) 를 작성했는데 이는 만일 클라이언트가 
   				   "/goodsDetail/10" URL 경로로 요청하면 @PathVariable을 통해 URL 경로에 작성된 식별자 값 10이 추출된 후 
   				   파라미터 변수 'bookId' 변수에 대입되어 사용하게 된다.
   				   
	* 뷰
	
	<순서>
	
	1. search.jsp : 검색 페이지 -> 상품 상세 페이지로 이동할 수 있도록 <a>태그를 추가 후 책 이름을 클릭하였을 경우도 이동할 수 있게 해줌
	
	2. goodsDetail.jsp 
	
	3. 이미지, 출판일 출력 : <script> 태그를 이용
	
	================================== 장바구니 기능 ================================
	
	장바구니 기능을 구현을 목표
	
	<순서>
	
	1. 방향 : 등록 , 수정 , 삭제 등의 기능이 있는 장바구니를 구현. 수량과 함께 장바구니 등록 버튼을 누르면 등록
			 만일 이미 등록한 상품이 장바구니에 있는 경우 새로 등록하지 않고 이미 있다는 경고문 출력
			 수량을 변경하는 버튼 구현, 삭제를 하느 버튼 구현, 로그인한 경우 장바구니 링크를 만들어 장바구니 페이지로 가는 기능 구현
			 만일, 로그인을 하지 않았다면 메인페이로 이동
			  
	
	2. 장바구니 테이블 생성
	
	3. CartVO
	 
	4. CartMapper.java : 카트 추가, 카트 삭제, 카트 수정, 카트 목록, 카트 체크 등 메서드를 구현
						
						addCart()는 vam_cart 테이블의 row를 추가하는 메서드. memberId, bookId, bookCount가 필요해 CartVO를 매개변수로 받음
						반환타입은 row 추가 성공 시 1, 실패 시 0을 반환하도록 int로 지정
						
						deleteCart()는 vam_cart의 row를 삭제하는 메서드. row 를 삭제하기 위해서는 cartId에 대한 정보가 필요
						파라미터 변수를 cartId로 지정, addCart와 같이 성공 시 0, 실패 시 1 로 확인 가능하게 반환타입은 int로 설정
						
						modifyCart()는 cart테이블의 지정한 row의 수량을 변경하는 메서드. 어떤 row인지 지정을 위한 cartId와 몇 개의 수량으로 변경할지에 대한 bookCount가 필요
						두 값을 한 번에 가져오기 위해 CartVO타입을 매개변수로 선언. 앞과 동일하게 성공 여부를 알기 위하여 반환타입을 int로 지정
						
						getCart는 cart테이블에서 지정한 모든 row의 값들을 가져오기 위한 메서드. 어떤 회원인지에 대한 정보인 String memberId를 파라미터로 선언
						반환 타입은 한 개 이상의 데이터를 반환받아야해 List<CartVO> 로 지정
						
						checkCart는 회원정보와 상품정보를 넘겨서 해당하는 row가 있는지 확인하기 위한 메서드. 회원정보(membetId), 상품정보(bookId)를 한번에 넘기기 위해
						CartVO 타입의 매개변수로 선언. 조건에 맞는 row의 컬럼값을 가져오도록 반환타입을 CartVO로 지정 
	
	5. 장바구니 테이블
	
	6. 인터셉터 적용 : 로그인한 사용자만 사용할 수 있도록 하기 위해서 관리자 페이지와 같이 interceptor 적용을 목표
	
	6-1. servlet-context.xml
	
	6-2. CartInterceptor.java : HttpSession 객체를 사용해 session을 얻어오고 세션에 "member"라는 키로 사용자 정보 데이터를 저장 후
								MemberVO 객체의 mvo 변수에 저장, mvo 변수에 값이 없다면(로그인 정보가 없다면) main 페이지로 이동
								로그인이 되어있다면 "/cart/**" 카트 페이지로 이동
								
	7. 서버 측 구현
	
	7-1. 뷰로부터 장바구니 추가 요청을 받으면 DB에 등록할 데이터인 memberId, bookId, bookCount 를 전달 받음
	
	7-2. 전달받은 memberId 와 bookId는 동일한 데이터를 가지는 vam_cart행이 있는지 확인하고 존재하지 않으면 DB에 새로운 행 추가
	
	7-3. 화면의 이동이 없는 비동식 방식으로 뷰는 요청하도록 할 것, http바디에 바로 데이터를 삽입해 반환
	
	7-4. 뷰는 숫자를 반환 받음 ( 0: 등록실패 , 1: 등록성공 , 2: 등록된 데이터 존재, 3: 로그인 필요 )

	View에서 ajax를 이용해 장바구니 등록을 요청하면 memberId, bookId, bookCount를 서버로 전송하고
	서버에선 '로그인 여부' , '기존 데이터 존재 여부' 등을 거쳐서 '장바구니를 추가' 후 그 결과 숫자를 View로 반환
	
	CartInterceptor가 있어 "/cart" url의 경로를 타는 모든 요청을 인터셉터를 거치게됨.
	하지만 '장바구니 등록' 메서드는 로그인에 관해서도 체크하여 그 결과를 반환하도록 만들어 CartInterceptor에 예외를 설정
	
	8. CartMapper 수정 : addCart()를 실패했을 때 0이 반환되도록 목표 (예외처리 사용)
	
	9. 장바구니 추가 , 뷰 구현
	
	9-1. 개요 : goodsDetail.jsp 에서 memberId, bookId, bookCount 의 데이터 값들을 세팅하고, 
			   "/cart/add" URL로 '장바구니 추가'를 요청하며 세팅한 값을 서버로 전송한 뒤 서버가 반환해 주는 값에 따라
			   경고창을 띄운다. 그리고 수량 버튼을 "+" , "-" 버튼 동작 하도록 구현 후 위 데이터들을 Ajax 호출할 때 같이 전송되도록 구현
	
	9-2. 수량 버튼
	9-3. '장바구니 추가'버튼
	9-4. 테스트
	
	10. cart.jsp 구현
	
	10-1. 상단에 로그인 옆에 마이룸 , 장바구니 , 고객센터 등이 나오도록 구현
		  첫 번째 사용자의 장바구니 정보 출력
		  두 번째 사용자의 장바구니 정보를 종합한 정보를 출력
		  세 번째 사용자가 취소를 선택할 수 있도록 checkbox를 이용, 그 에따라 종합정보가 변경
		  네 번째 장바구니에 상품 이미지 출력
		  
    11. cart.jsp에서 상품 칸'체크 박스'의 체크 여부에 따라 '종합 정보 섹션'의 데이터들이 변경 되도록 구현하는 것이 목표
		체크한 상품만 주문할 수 있도록 데이터가 넘겨지고, 장바구니 상품 페이지에서 종합정보(총 가격, 수량)이 체크가 변경될 때마다 실시간으로 변경을 구현
		
		체크 박스의 변화에 따라 종합정보 섹션의 데이터가 업데이트. 변화가 있을 때마다 페이지의 렌더링될 때 실행되도록 체크 유무 조건에 따라서 종합될 정보가 변화도록 구현
		
	12. 개별 체크 박스(태그 추가) : js에 if문을 주어 is()메서드 사용해서 변화가 있을 경우에 정보 변경이 적용되게 구현
	
	13. 체크박스 전체 선택
	
	.attr()을 통해서는 element가 가지는 속성값이나 정보를 조희(style, src, rowspan등) 하거나 세팅 , html 속성(attribute)를 다룬다. 		/ attr은 HTML 속성 값이 모두 String 타입
	.prop()을 통해서는 element가 가지느 실제적인 상태(활성화, 체크, 선택여부 등)을 제어하는 업무 , javascript 프로퍼티(property)를 다룬다.	/ prop은 boolean, date, function 등으로 가져오기 가능
	각 사용하는 목적에 따라 다를 수 있지만 prop()가 attr()보다 약 2.5배 빠르다는 장점이 있다.
	HTML의 속성을 가지고 오고 싶을 때는 attr()을, javaScript로 수정된 요소의 값을 가지고 싶을 때 prop()을 사용하는걸 선호
	보통 체크박스를 컨트롤할 때, 체크 여부도 알아 볼 수 있다.
	
	https://yeonzzy.tistory.com/21 참고
    
    14. 이미지 출력 
    
	이미지를 출력하려면 이미지 정보(파일 이름, 파일 경로, uuid)가 필요. 장바구니 페이지로 이동하는 Controller의 URL 매핑 메서드가 '장바구니 view'로 상품의 이미지 정보를 전달
	
	전달하기 위해서 이미지 정보를 가지는 객체를 따로 생성해주지 않고 기존 장바구니 정보를 넘기는 CartVO에 이미지 정보를 함께 담도록 할 것. 
	
	이미지 정보를 담는 작업은 비지니스 로직을 구성하는 Service 단계에서 실행. 이미지 정보를 호출하는 AttachMapper 클래스의 getAttachList() 메서드를 활용    
    
    15. 장바구니 수량 수정 : 장바구니 페이지 상품란에 수량을 변경 후 '변경' 버튼을 누르게 되면 '장바구니 테이블'의 수량이 변경되도록 구현
    
    뷰에서 수량 변경 요청과 함꼐, 장바구니 id(cartId), 변경 수량(bookCount)를 전달 받으면 DB의 장바구니 테이블 수량을 변경하도록 할 것
    
    <Server>
    
    DB 장바구니 수량 변경 쿼리가 동작하도록 만드는 Mapper메서드 (modifyCount())가 있으니 Service 로직에서 이를 호출하도록 구현
    
    <View>
    
    '수량 변경'버튼을 추가하고 data속성을 이용해 data-cartid를 사용해 cartId의 데이터를 심는다.
    
    
    ==================================== 장바구니 삭제 버튼 ==========================================
    
    뷰에서 삭제 요청과 함께 "장바구니 id(cartId)" 를 전달받으면 DB에 cart테이블에서 요청받은 cartId에 해당하는 행을 제거
    
    즉, 뷰에서 사용자가 삭제하고자 하는 물품에 '삭제'버튼을 누르면 '장바구니 품목 삭제' 요청과 함께 cartId를 함께 전송
    
    
    
    ===================================== 주문 기능 구현 ==========================================
    
    '주문 구현' 과 '주문 테이블' 을 생성
    
    '주문 구현'은 장바구니 또는 바로 구매를 구현, '주문 취소' 기능 구현
    
    [주문 구현] 
    
    - 주문 버튼을 눌러 '주문 페이지'로 이동
    - 주문자의 배송 정보를 입력하고 사용할 point를 입력
    - 사용자가 주문 버튼을 누르면 재고, 사용자의 돈, 포인트가 차감되고 주문 상태가 '배송 준비'로 DB에 반영
    - 주문이 정상 작동하면 메인 페이지로 이동
    
    [주문 취소]
    
    - 관리자 계정에서 '주문 현황'을 볼 수 있고, 취소 버튼을 누르면 주문이 취소
    
    [주문 테이블]
    
    한명의 회원이 여러 번의 주문을 할 수 있지만 주문은 반드시 한명의 회원에 속해 있어야 한다.
    즉, 회원과 주문은 일대다 관계( 1:N )
    하나의 주문에 여러 개의 상품을 가질 수 있고, 하나의 상품은 여러 주문에 속할 수 있기 때문에 서로 다대다 관계( N:N )
    하지만 DB는 물리적으로 N:N관계가 존재할 수 없어 '주문' 과 '상품'의 관계를 가운데서 해결해주는 '주문_상품' 매핑 테이블을 만듦
    ( N:N -> 1:N , N:1 )
    
    '주문 테이블' vam_order 테이블 , '매핑 테이블' vam_orderItem을 생성
    
    vam_orderItem 테이블에 savePoint라는 컬럼이 있는데 이는 트랜잭션을 특정 부분에서 취소시킬 수 있는 명령어
     
    1. 페이지 구현(order.jsp) : cart.jsp 와 goodsDetail.jsp 에서 주문 페이지로 이동 가능
     
    주문 페이지에서 상품을 주문하려면 필요한 데이터는 '상품' , '회원' 의 기본키인 memberId, bookId 그리고 수량인 bookCount를
    서버에 전달시켜 필요한 데이터를 만들어 낸 후 order.jsp에 넘긴다.
    하지만 두 개 이상의 상품정보를 클라이언트에서 서버로 넘기기 위해선 3개의 변수만 선언된 객체로는 넘길 수 없어 
    bookId, bookCount만 담는 클래스를 만든 후, 이 클래스를 요소로 가지는 List 객체 타입 변수로 가지는 클래스를
    URL 매핑 메서드의 파라미터로 선언
    
    2. OrderPageItemVO : 뷰로부터 데이터를 전달받을 객체가되는 클래스를 생성
    				  이 클래스는 뷰에서 서버로 데이터를 전달하고 서버에서 뷰로 상품 관련 데이터를 담을 그릇 역할
    
    
    3. OrderPageVO : OrderPageItemVO 의 객체를 요소로 가지는 List 타입의 변수를 가지는 클래스
    			  여러개의 상품 정보를 넘기기 위해 List 타입을 가지는 클래스 생성
    			  
    4. OrderController 생성
    
    5. View 처리
    
    5-1. goodsDetail.jsp : 장바구니 페이지로 데이터를 전송하기 위한 form 태그 추가
    
    5-2. cart.jsp : 주문 하기 버튼을 눌렀을 때 선택한 물품들에 대한 <input> 태그가 동적으로 구현
    
    ======================================= 주문 페이지 구현 ================================
    
    주문페이지(order.jsp)를 만듦. cart.jsp에서 서버로 데이터를 전송 작업을 진행했을 때 그 데이터를 받아
    Model객체를 통해 뷰로 데이터 전달하는것 까지 구현 목표.
    
    첫 번쨰 정보는 회원의 개인 정보(회원의 이름, 주소, 이메일), 회원의 소유 포인트
    
    두 번째 정보는 회원이 주문하고자 하는 상품의 정보(DB로부터 가격, 할인율, 사용자가 낼 총 가격, 포인트)
   
    위의 두 정보를 만드는 Mapper, Service 로직을 구현 후 Controller에서 앞서 만든 Service를 호출하여 
    Model 객체를 활용해 'order.jsp'로 전송 하도록 작업
    
    주문 페이지로 전송할 상품 정보를 만들어 낼 작업을 위한 메서드를 OrderMapper, OrderService, 등등으로 작성
    Service에서는 여러 개의 상품 정보를 만들고 반환해야 하기 때문에 List타입으로 반환타입으로 지정
    
    1. 주문 페이지 구현( order.jsp ) : 주문 페이지에선 최종으로 데이터를 확인할 하는식으로 구현
    								회원 정보(이름, 연락처) , 배송지 정보(저장된 배송정보 or 직접 입력) , 주문 상품 정보(주문할 상품 정보)
    								포인트 사용 유무( 사용 가능한 포인트 정보 or 사용하는 포인트 입력란 ) , 최종 주문 정보( 최종 결제 비용 (포인트에 따라 다름) )
    								
    								 
	2. 기본 틀 : order.css 생성 및 order.jsp 틀 구성
	
	3. 회원 정보 틀 구성과 DB에서 meberInfo.memberName 과 memberInfo.memberMail 을 반환
	
	4. 배송지 정보 : 회원 가입 때 적었던 배송지를 선택하거나 새로 입력할 수 있게 선택지 구현
				   버튼을 클릭함에 따라 색상 변경과 표시 숨김 기능을 js로 구현
				   
    5. 상품 정보 : 회원이 주문한 상품이 무엇인지 모는 부분으로 cart.jsp의 '상품 정보' 작업과 동일
			     
			     * 상품 정보에서 javax.el.PropertyNotFoundException 에러 발생 - OrderPageItemVO에 salePrice의 getSalePrice() 메서드에 오타 발견
    
    6. 포인트 사용 입력 : 회원이 소유한 포인트를 얼마나 사용할 것인지 입력하는 란
    
    6-1. 회원이 가진 포인트를 확인할 수 있도록 '회원 포인트' 출력 : 포인트는 0보다 작으면 안되고, 최대포인트를 넘어서 입력을 해서도 안된다.
    
    6-2. 0원 이상 회원이 가진 포인트 이하의 숫자만 입력되도록 구현
    
	7. 버튼
	
	7-1. '전액 사용' 버튼 : 해당 버튼을 클릭하면 '전액 사용' 버튼이 보이지 않게되고, '사용 취소' 버튼이 보이게 된다.
						  포인트 입력란이 '사용 가능 포인트' 에 최댓값이 입력
	
	7-2. '사용 취소' 버튼 : 해당 버튼을 클릭하면 '사용 취소' 버튼이 보이지 않게되고, '전액 사용' 버튼이 보이게 된다.
		    			  포인트 입력란이 0이 입력된다.
		    			  
    7-3. Y : 전액 사용 버튼 / N : 모두 취소 버튼   인데, 이를 구별하기 위한 변수 state를 사용하고 html에 있는 data-state를 사용해여 데이터를 얻는다
    
    8. 주문 종합 정보 : 사용자의 주문 정보에 따라서 사용자가 지불해야 할 비용 정보를 종합해서 보여주는 섹션
     				  이는 확정 물품이기 때문에 '장바구니 페이지' 의 종합처럼 체크함에 따라 변경이 될 상황은 없다.
     				  하지만 '주문 페이지'에서는 회원이 자신이 사용할 '포인트'에 따라 지불할 값이 달라지기 때문에
     				  '주문 종합 정보'에 변동이 생김. 
     				  
     				  '주문 정보 종합'이 담길 태그를 추가하고 js코드를 통해 '포인트' 사용에 따라 지불 값이 달라지는 기능을 구현
     				  
     				  값 삽입
     				  toLocaleString() 메서드를 사용 - Number , Date , Array 타입에 많이 사용한다.
     				  
     				  Number - 보통 간단하게 천단위마다 콤마를 추가할 떄 주로 사용
     				  Date - 사용자의 문화권에 맞는 시간 표기법으로 년,월,일 시간을 리턴
     				  Array - array의 내용을 다 문자로 반환해서 보여줌
	
	9. 상품란에 이미지 삽입
	
	[Server] 측 구현
	
	order.jsp 에서 결제하기 버튼을 눌렀을 때 서버로 요청한 주문 데이터를 넘기는 것이 목표
	
	1. 배송지 , 사용 포인트, 사용자 주문 상품 정보를 넘겨줘야 한다.
	   즉, 뷰에서 주문을 전송하는 form태그를 작성해서 서버로 보내야하고, '결제하기'버튼을 눌렀을 때
	   form태그에 input값이 세팅된 후 서버에 form태그의 정보들이 전송되야함
	   서버에서는 뷰의 요청을 받아 뷰에서 전달받은 데이터를 사용해 주문 작업을 수행
	
	2. VO 생성 : OrderVO, OrderItemVO 를 생성. OrderVO 는 '배송정보 , 사용 포인트 정보 , 여러가지의 주문 상품 정보' 를 담는다.
						  					 OrderItemVO 는 '하나의 주문 상품 정보' 를 담는다. 
										
	3. DB로부터 저장된 정보(할인율, 상품가) , 다른 하나는 주문 작업에 필요로한 정보(배송비, 최종비용(상품가 + 배송비 - 사용포인트)) 이 두가지 정보를 더 담도록
	   만들기 위해 Order에 관한 VO객체를 다시 만들었음
	   즉, 새로 생성한 VO 클래스들은 뷰 -> 서버 로 전송할 정보, DB에 꺼내올 정보, DB에 등록할 정보, 주문 비지니스 로직에 필요한 정보를 담는 역할을 한다.			
	
	4. 배송지 정보 판단 (T , F) : 배송지는 기본 배송지 또는 사용자 직접 입력 배송지를 사용할 수 있는데, 뷰에서 서버에 데이터를 전송하기 위해 배송지 정보를 가져올 때 
	  						   회원이 어떤 방식을 선택 했는지 판단할 수 있게 'T : 기본 배송지 , F : 직접 입력'  
    
    5. /order 매핑 메서드 추가
    
    6. Mapper 추가 : 총 6개의 Mapper메서드를 구현. "주문"을 처리할 때 Service에서 Mapper 메서드가 6개를 사용할 것인데 이는 하나의 "주문 요청"이 들어오면
    				6개 이상의 쿼리문이 실행된다는 말이다. (CartMapper , OrderMapper에 추가)
    
    7. Service 메서드 작성 : 주문 데이터를 DB에 등록해주고, 주문 상품의 비용과 포인트, 회원 정보의 돈과 포인트에서 차감하거나 더해줌
    					   주문한 상품 수 만큼 재고에서 차감, 회원이 장바구니 경로를 통해 주문을 한 경우, 주문이 이루어진 장바구니 상품 정보를 제거
    					   
	7-1. 사용할 데이터 세팅 (MemberVO , OrderVO)
	
	7-2. 주문 데이터 DB에 등록 : OrderVO 객체의 orderId 값을 부여, "회원 아이디" + "_년도 월 일 분" 형태로 SimpleDateFormat 객체 활용
	
	7-3. 비용, 포인트의 변동을 DB에 적용
	
	7-4. 재고 차감 DB 적용
	
	8. Controller에서 위에 작업한 Service 메서드인 order()를 호출한다. 그리고 회원 정보 부분의 "member" 데이터를 최신화 해야한다.
	   적용되지 않는다면 구매 이전의 정보들이 그대로 남아있을 것이기 때문.
	
	7-5. 장바구니 상품 정보 DB 제거
    
    8. Controller 수정
    
    ==================================================== 주문 현황 ==============================================================
    
    관리자 페이지에서 '주문 현황'페이지를 이동 할 수 있는 링크를 추가하고, 이를 클릭하였을 때 DB에 등록된 주문 정보가 출력되도록 구현
    그리고 회원 아이디를 검색할 수 있도록 '검색' 기능 또한 구현
    
    1. AdminMapper : 주문 현황 페이지에 출력 할 DB에 저장된 '주문 정보'와 페이지 번호를 만들 때 필요한 '주문 데이터 총 개수'를 반환해주는 Mapper 메서드 작성
    				 검색에 대한 기능을 구현해야하기 때문에 '현 페이지, 검색 키워드 등등' 에 맞는 쿼리가 실행되어야해 조건이 알맞은 Criteria를 매개변수로 받는다.
    
    2. AddminService : Mapper 메서드를 호출하는 메서드
    
    3. AdminController :  '주문 현황 페이지' 요청을 수행하는 URL 매핑 메서드 구현
    
    4. View 처리 
    
    ==================================================== 주문 취소 ===============================================================
    
    주문 취소 기능
    
    1. 개요 : 주문 취소는 '회원' 가 '관리자' 두 경우가 있다.
    
    1-1. '주문 현황' 페이지에서 "배송준비" 상태인 경우에만 "주문 취소" 버튼이 보임
    1-2. 버튼을 누르면 "주문 취소" 요청을 서버에 요청
    1-3. 서버에서는 "주문 금액, 포인트, 재고" 반환
    1-4. 주문 관련 테이블의 데이터는 지워지지 않고 vam_order 테이블의 "주문 상태"의 값이 변함
    1-5. 서버는 "주문 취소"가 완료되면 주문 현황 페이지로 리다이렉트
    
    2. Mapper : vam_order 테이블의 주문 상태 컬럼을 "배송준비" -> "주문취소" 로 변경하는 쿼리
    			vam_order 테이블의 데이터를 가져오는 쿼리와 vam_orderItem 테이블의 데이터를 가져오는 쿼리를 메서드로 구현
    			
	3. OrderCancleVO : 뷰가 요청하면 전송할 데이터를 담는 역할을 하는 VO 클래스(model)
	
	4. OrderService : '주문 취소'는 '주문' 과 크게 다르지 않음. 단지 '주문 취소'는 vam_cart 데이터를 삭제하지 않고
					  사용했던 금액과 포인트를 다시 추가
					  
    4-1. DB에 저장된 주문, 주문 상품 정보를 가져옴
    4-2. 꺼내온 정보를 통해 회원이 지불한 금액, 포인트, 받았던 포인트 값을 구함
    4-3. 주문 , 주문 상품 정보의 데이터를 활용해 '돈' , '포인트'를 더해줌
    4-4. 회원이 상품을 구매함으로써 받은 포인트를 회수 , 차감했던 재고들을 다시 추가
    
    5. Controller : AdminController 에 작업, OrderService 사용
    
    6. view 처리 : 버튼 추가
    
    7. 테스트 : org.apache.ibatis.builder.BuilderException 에러가 발생. Mapper.xml의 resultType에 에러가 있었음
    		   구매 후 메인 페이지를 갔을 때 정보를 최신화 하기위해 session을 사용
  
  	================================ 게시판 댓글 & 평점 구현 ===========================================
  	
  	1. 댓글 & 평점 기능 : 상품 페이지에서 회원들이 작성한 댓글과 평점을 확인할 수 있다. 로그인한 사용자는 댓글 등록 버튼을 누르면
  					    댓글 & 평점을 등록하고, 자신이 작성한것들은 수정이나 삭제 가능하다.   
  					    기본적인 CRUD ( Create, Read, Update, Delete ) 구현
  					    
    1-1. Create : 로그인한 회원이 '상품 상세 페이지'로 이동하면 '댓글 등록' 버튼이 보임
    			  '댓글 등록' 버튼을 누르면 작성하는 팝업창 뜸, '등록' 버튼을 누르면 DB에 댓글 등록 완료
    			  이 등록 과정에서 vam_book의 평점이 최신화, 등록이 완료되면 팝업창이 닫히고 '상세 페이지'에는 등록된 댓글을 볼 수 있음
    			  
  	1-2. Read : '상세 페이지' 하단에 10개 단위로 페이징 된 댓글을 보는 것이 가능
  				댓글 리스트 하단에 페이징 기능
  				페이징 버튼을 클릭하면 페이지 이동 없이 댓글 리스트가 변경
  				
	1-3. Update : '상품 페이지'에서 회원이 작성한 댓글을 '수정 버튼'으로 수정할 수 있음
				  수정하면 수정 내용이 DB에 최신화, 수정이 완료되면 팝업창이 닫히고 '상품 수정 페이지'에 댓글이 수정한 댓글로 최신화
				  
  	1-4. Delete : '상품 페이지'에서 회원이 작성한 댓글이 있는 경우 자신의 댓글에 대하여 '삭제' 버튼이 보인다.
  				  '삭제'버튼을 누르면 DB에 댓글 정보가 삭제, vam_book의 평점이 최신화, 페이지 이동 없이 댓글 리스트 최신화
				  
   
   2. 댓글 테이블 : 관계를 생각해보면 회원은 여러개의 댓글을 작성할 수 있다. ( 1 : N , 일대다 관계 )
   	 (vam_reply)  댓글은 반드시 하나의 상품에 속해야 하므로 댓글과 상품은 ( N : 1 , 다대일 관계 )
   				  회원은 여러가지 댓글을 달 수 있으나, 하나의 상품에는 하나의 댓글만 작성할 수 있도록 구현
   				  댓글 테이블에서 회원, 상품 외래 키 두 개를 하나의 단위로 하는 UNIQUE 제약조건 적용
   				  
   3. ReplyVO
   
   4. Mapper
   
   5. Service
   
   6. Controller : 댓글 요청인 부분에서 뷰를 만들지 않고 http의 body 부분 데이터를 담아 반환할 것
   				   이런 경우에 @RestController 어노테이션 추가
   				   
   7. 리뷰 등록 팝업창 구현
   
   7-1. 리뷰 css
   7-2. 팝업창 버튼(goodsDetail.jsp) : 버튼을 누르면 팝업창이 뜨게 구현
   7-3. 팝업창 이동(서버) : 뷰에서 bookId , memberId를 전송하도록 구성, 이 데이터를 그대로 리뷰 등록 팝업창(뷰)로 보내 줄 것
   						 팝업창에서 자신이 어떤 상품의 리뷰를 등록했는지 알 수 있도록 '상품 이름' 도 뷰로 보내줄 것
   						 bookId 값을 통해 bookName 값을 반환해주는 Service 메서드를 만들고 리뷰 등록 팝업창(뷰) 이동 URL 매핑 메서드 구성
   				
   8. 리뷰 등록 팝업창 태그 , css
   
   9. js
   
   10. 테스트
   
   ========================================== 댓글 페이징 기능 ============================================
   
   1. 개요 : '상품 상세 페이지'에 등록되어 있는 댓글 리스트를 보도록 구현 ( 페이징은 게시물과 동일하게 1~10까지 보이게 구현 )
   			기존 페이징의 경우 서버에서 페이징 된 뷰를 반환했지만, 댓글 페이징의 경우 단순히 서버로부터 댓글과 페이징 정보를 전달받아
   			뷰에서 동적으로 댓글 태그들을 만들어내야한다.
   
   
   2. VO : Criteria(변수 하나 추가) , ReplyPageDTO 클래스 사용
    
   3. Mapper
   
   4. Service
   
   5. Controller : 매핑 메서드에서 produces = MediaType.APPLICATION_JSON_UTF8_VALUE 를 @GetMapping의 매개변수로 넣었다.
   				   HTTP 응답 헤더로 "Content-Type: application/json;charset=UTF-8"을 반환
   				   즉, 서버에서는 JSON 형식의 바디만 처리하겠다는 의미.
   				   
   6. 흐름 : view에서 댓글 페이지 정보를 요청 -> bookId와 페이징 정보(pageNum), 표시량(amount)를 서버로 전송 -> "reply/list" url 매핑 메서드 동작 
   	-> 댓글 페이징 정보를 만들어 내는 Service 메서드 호출 -> '댓글 페이징 정보' , '댓글 총 개수' 를 반환하는 Mapper 메서드 호출 -> '댓글 총 개수'의 값은 PageDTO 객체를 만드는데 사용
   	-> Service 에서 ReplyPageDTO 객체를 생성해 '댓글 페이징 정보' 와 '페이지 정보'를 담은 후 객체를 반환 -> Controller은 반환받은 ReplyPageDTO 뷰로 전송 
   	-> ReplyPageDTO는 JSON 데이터로 변한되 뷰로 전송 
   	
   7. 뷰 측 구현 : 서버로부터 반환 받은 댓글 페이지 정보를 활용해 동적으로 태그를 만들어 줄 것 (goodsDetail.jsp)
   
   8. 동적 태그 생성(JavaScript) : goodsDetail.jsp에서 사용자가 이동했을 떄 댓글 리스트가 출력. 
   								렌더링을 이용해 js 코드 구성. 이 서버 요청을 하기 위해선 ajax를 사용하지만 JQUERY가 지원하는
   								GET 메서드 방식으로 서버에 요청할 때 사용하는 getJSON() 메서드를 사용
   								getJSON(a, b, c); -> a : 요청 url , b : 서버에 전송할 데이터 , c : 서버로부터 응답을 성공했을 때 동작할 코드 
   
								현재 ReplyController에 있는 replyListPOST() 메서드는 반환객체가 ReplyPageDTO인데 
								'댓글 리스트 정보'를 구하는 이 매핑 메서드에는 매개변수로 produces = MediaType.APPLICATION_JSON_UTF8_VALUE 가 들어가 있다.
								JSON은 JavaScript 객체 리터럴 문법을 따르기 때문에 그 자체로 javascript 객체이다.
								그렇기 때문에 객체의 프로퍼티 접근 방식으로 list(댓글 정보) , pageInfo(페이지 정보)에 접근 가능
								
								화면이 렌더링 될 때뿐만 아니라 회원이 댓글을 수정, 등록, 삭제, 페이지 이동의 경웨도 똑같은 작업을 해야함
								위 작업은 replyEnroll.jsp에서 함
								
	9. 댓글 초기화 메서드(등록, 수정, 삭제, 페이지 이동) : 댓글을 등록, 수정, 삭제, 페이지 이동할 때 해당 댓글 정보를 가지고 데이터가 초기화.
												   총 4가지 상황에서 각 메서드를 호출해야함
												   
	10. 댓글 등록 : 서버에 댓글 등록 요청이 성공했을 떄 팝업창을 닫아주도록 구현. $(opener.location)은 '부모 창 함수 접근' 이다.	
				   자바스크립트에는 부모창이 있고 자식창이 있다. 처음에 버튼을 클릭하는 페이지가 부모창이고, 자식창은 그 외 여러가지 있다.(팝업, 아이프레임, 기타 등등)
				   위 프로젝트에선 자식창은 '팝업창' 이다. 그러므로 '팝업창'을 띄우게 되면 부모창의 정보를 가지고 있고, 자식창에서 부모창을 가리키는것이 '팝업'일 경우 opener라는 객체를 사용
				   $(opener.location).attr("href", "javascript:replyListInit();") -> JQUERY를 이용해 팝업창에서 부모창 함수를 호출하는 방식
				   
    11. 댓글 날짜 형식 변환 : 달리는 댓글의 날짜 형식이 이상하므로 "yyyy-MM_dd" 형식으로 날짜 출력하게 구현. Date타입은 json으로 변환할 경우 "yyyy-MM-dd" 형식으로 변환되지 않아
    					   Date 타입의 데이터에 어떤 포맷으로 변환할지 지정
    					   
    					   ReplyVO 클래스안에 regDate 변수를 json으로 변환 시 지정 형식으로 변환해주는 어노테이션을 사용
    					   @JsonFormat(shape= JsonFormat.Shape.STRING, pattern="yyyy-MM-dd", timezone="Asia/Seoul")
	
	========================================================= 댓글 체크 기능 =============================================================		
	
	한 회원은 같은 상품에 대해서 한번 이상의 댓글을 작성할 수 없다.(vam_reply의 unique 제약조건)
	
	1. 흐름 
	
	"댓글 등록" 버튼 클릭 -> "팝업창 댓글 및 리뷰" 작성 -> "등록" 버튼 클릭 -> 해당 회원이 해당 상품에 대해 댓글을 적은적이 있는지 없는지 체크
	
	2. Mapper : 반환타입을 int가 아닌 Integer를 사용 . memberId 와 bookId를 조건으로 하는 행이 존재하지 않으면 MyBatis는 null 값을 반환하는데
				int타입은 null이 없어 에러가 발생, 이런 이유로 null 값도 가질 수 있는 Integer를 반환 타입으로 지정 		   
	
	3. Serive : String을 반환타입으로 한 메서드를 구성해 Mapper쿼리의 결과에 따라 댓글이 있으면 "1"을 없으면 "0"을 반환
	
	4. Controller : Service에서 반환받은 문자열을 반환
	
	5. 뷰 구현
	
	========================================================= 댓글 수정 ===========================================
	
	1. Mapper : 수정쿼리가 정상적으로 수행되면 1을 반환 (int 타입)
	
	2. Service
	
	3. Controller
	
	4. 댓글 수정 팝업창 뷰 : BookController에 작성. 댓글 팝업창에는 회원이 작성했던 데이터가 출력되어야해서 DB에서 댓글 데이터를 꺼내오는
						  Service 메서드를 만들어야함
						  
	5. 상품 상세페이지 '수정' 버튼 동작(javascript)
	
	6. 수정 팝업창
	
	6-1. 틀
	6-2. DB 등록 데이터 반환
	6-3. 버튼 동작
	
	7. 테스트
	
	====================================== 댓글 삭제 ============================================
	
	상품 상세 페이지에서 '삭제'버튼을 누르면 서버에 댓글 삭제가 요청되고, 서버에서는 댓글 정보를 DB에서 삭제하는 작업을 처리
	그 후 상세페이지에 있는 댓글 리스트 최신화 작업
	
	======================================= 상품 테이블 평균 평점 갱신 ===============================================
	
	vam_book 테이블에 ratingAvg 컬럼을 추가해 댓글의 '등록 , 삭제 , 수정' 을 할 때 상품의 평균 평점 값이 최신화 하는 기능
		
	